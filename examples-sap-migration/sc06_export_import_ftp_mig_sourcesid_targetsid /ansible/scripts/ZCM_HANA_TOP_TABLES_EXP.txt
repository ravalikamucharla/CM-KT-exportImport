*---------------------------------------------------------------------*
* Program Name        :   ZCM_HANA_TOP_TABLES_EXP                     *
* Title               :   Top Tables for HANA Database                *
* Purpose             :   This report is used to fetch top 100 tables *
*                     :   in the system                               *
*---------------------------------------------------------------------*
* Related Transaction OR Standard Program References                  *
* DBACOCKPIT                                                          *
*---------------------------------------------------------------------*
* Program Change History                                              *
*---------------------------------------------------------------------*
* Date        Version   Author       TR#/Local     Description        *
*---------------------------------------------------------------------*
* 07-02-2020 Initial Ruchir Kamble FIOK900653 To fetch top 100 tables *
* 05-26-2021 V001    Ruchir Kamble FIOK900653 To add dynamic structure*
* 02-02-2022 V002    Yasaswini K   Local      To add schema in input  *
* 08-17-2022 V003    Soumya Ray    Local      To pass message "No data*
*                                             found" in case of no    *
*                                             data found in sytem     *
* 11-17-2022 V004    Yasaswini K   Local      To get schema name      *
*---------------------------------------------------------------------*

REPORT zcm_hana_top_tables_exp.

LOAD-OF-PROGRAM.

FORM get_config
              TABLES lt_input  STRUCTURE tab512
                     lt_output STRUCTURE tab512.

*  Begin of changes in V001

  TYPES: BEGIN OF lty_table,
           schema_name          TYPE char512,           "+V002
           table_name           TYPE char256,
           memory_size_in_total TYPE char22,
           record_count         TYPE char22,
         END OF lty_table.

*  End of changes in V001

  CONSTANTS: lc_sep        TYPE c VALUE '|'                LENGTH 1,
             lc_top        TYPE c VALUE 'Top'              LENGTH 3,
             lc_fetch      TYPE c VALUE 'FETCH'            LENGTH 5,
             lc_table_name TYPE c VALUE 'TableName'        LENGTH 10,
             lc_size       TYPE c VALUE 'Size'         	   LENGTH 4,
             lc_no_rows    TYPE c VALUE 'NumberofRows'     LENGTH 15,
             lc_title      TYPE c VALUE 'Large Tables'     LENGTH 15,
*   Begin of changes in V001
             lc_inc_input  TYPE c VALUE 'Incorrect input'  LENGTH 20,
             lc_noinput    TYPE c VALUE 'No input given'   LENGTH 20,
*   End of changes in V001
*   Begin of changes in V002
             lc_comma      TYPE c VALUE ','                LENGTH 1,
             lc_schema     TYPE c VALUE 'SchemaName'       LENGTH 11,
             lc_max        TYPE c VALUE '2147483647'       LENGTH 10,
*   End of changes in V002
*   Begin of changes in V003
             lc_null       TYPE c VALUE 'NULL'             LENGTH 4,
             lc_err_msg    TYPE c VALUE 'No data found'    LENGTH 20.
*   End of changes in V003

  DATA: ls_input       TYPE tab512,
        ls_output      TYPE tab512,
        lv_action      TYPE char10,
        lv_num_tab     TYPE char10,
        lv_str         TYPE string,
        lv_query       TYPE string,
        lv_rawtime     TYPE string,
        lv_time_from   TYPE string,
        lv_time_to     TYPE string,
        lv_sql_stmt    TYPE string,
        lv_msintotal   TYPE char22,
        lv_con_name    TYPE dbcon_name,
        lv_size        TYPE dec20_2,
        lr_dref        TYPE REF TO data,
        lr_ref         TYPE REF TO data,
        lr_convert     TYPE REF TO cl_hdb_adbc,
        lr_sql_excp    TYPE REF TO cx_sql_exception,
        lr_second_con  TYPE REF TO cl_sql_connection,
        lr_stmt_ref    TYPE REF TO cl_sql_statement,
        lr_result      TYPE REF TO cl_sql_result_set,
        lr_set         TYPE REF TO cl_sql_result_set,
*  Begin of changes in V001
        lv_date_msg    TYPE string,
        lv_exe_msg     TYPE string,
        lv_con_msg     TYPE string,
        lr_metadata    TYPE REF TO data,
        lt_metadata    TYPE adbc_rs_metadata_descr_tab,
        lr_tabletype   TYPE REF TO cl_abap_tabledescr,
        ex_structdescr TYPE REF TO cl_abap_structdescr,
        ex_result_ref  TYPE REF TO data,
        lr_structdescr TYPE REF TO cl_abap_structdescr,
        lr_structure   TYPE REF TO data,
        lt_table       TYPE STANDARD TABLE OF lty_table,
        ls_table       TYPE lty_table,
*  Begin of changes in V002
        lv_schema      TYPE string,
        lv_num         TYPE char10,
        lv_count       TYPE char11,
        lt_table_tmp   TYPE STANDARD TABLE OF lty_table,
        lt_table_tmp1  TYPE STANDARD TABLE OF lty_table,
        lt_schema      TYPE STANDARD TABLE OF hdb_schema_name,
        ls_schema      TYPE hdb_schema_name,
*  End of changes in V002
        lv_dbschema    TYPE char16.                   "+V004

  FIELD-SYMBOLS: <fs_table>     TYPE STANDARD TABLE,
                 <fs_structure> TYPE any.

  " Clear variables before use
  CLEAR: ls_output, ls_input, ls_table, lv_action, lv_num_tab,
         lv_date_msg, lv_exe_msg, lv_con_msg, lv_str, lv_query,
         lv_rawtime, lv_time_from, lv_time_to, lv_sql_stmt,
         lv_msintotal, lv_con_name, lv_size.

  FREE: lt_table, lt_output.

* Begin of changes in V003
  ls_output = lc_title.
  APPEND ls_output TO lt_output.
  CLEAR ls_output.
* End of changes in V003

  " Read input file from Python
  READ TABLE lt_input INTO ls_input INDEX 1.
  IF sy-subrc EQ 0.
    SPLIT ls_input AT lc_sep INTO
    lv_action       " Action
    lv_num          " Number of tables to be fetched    "+V002
    lv_schema.      " Schema                            "+V002
  ELSE.
    " No input given
    ls_output = lc_noinput.
    APPEND ls_output TO lt_output.
    CLEAR ls_output.
    RETURN.
  ENDIF.

*  End of changes in V001
  CASE lv_action.

    WHEN lc_fetch.
*  Begin of changes in V003
      FREE: lt_output.
      " Adding title to the output
      CONCATENATE lc_top lv_num lc_title
      INTO ls_output SEPARATED BY space.
      APPEND ls_output TO lt_output.
*  End of changes in V003

*  Begin of changes in V004
      IF lv_schema IS INITIAL.

        CALL FUNCTION 'DB_DBSCHEMA'
          IMPORTING
            dbschema = lv_dbschema.

        IF sy-subrc = 0.
          lv_schema = lv_dbschema.
        ENDIF.

      ENDIF.
*  End of changes in V004

*  Begin of changes in V002
*  Fetching all the entries from DB
      SPLIT lv_schema AT lc_comma INTO TABLE lt_schema.
      lv_num_tab = lc_max.
      lv_count = lv_num + 1.
*  End of changes in V002

      TRY.
          lr_second_con = cl_db6_con=>get_connection( lv_con_name ).
          lr_stmt_ref   = lr_second_con->create_statement(  ).

          CLEAR: lv_str, lv_query.
          " Building query to fetch Application server time
          CONCATENATE
          ' SELECT MAX( SNAPSHOT_ID ) FROM '
          ' _SYS_STATISTICS.HOST_COLUMN_TABLES_PART_SIZE '
          ' AS HOST_COLUMN_TABLES_PART_SIZE   '
          INTO lv_query.

          TRY.
              lr_result = lr_stmt_ref->execute_query( lv_query ).
              GET REFERENCE OF lv_rawtime INTO lr_ref.
              lr_result->set_param( lr_ref ).
              lr_result->next( ).

              IF strlen( lv_rawtime ) > 14.
                lv_str = lv_rawtime(14).
              ENDIF.

              CONCATENATE lv_str+0(4) '-' lv_str+4(2) '-' lv_str+6(2)
                          ' ' lv_str+8(2) ':' lv_str+10(2) ':'
                          lv_str+12(2) '.000'
                          INTO lv_time_from RESPECTING BLANKS.

              " Setting date & time into the param tab
              GET REFERENCE OF lv_time_from INTO lr_dref.
              lr_stmt_ref->set_param( lr_dref ).

              lv_time_to = '9999-12-30 23:59:59.000'.
              GET REFERENCE OF lv_time_to INTO lr_dref.
              lr_stmt_ref->set_param( lr_dref ).

            CATCH cx_sql_exception INTO lr_sql_excp.
              lv_date_msg = lr_sql_excp->get_text( ).
              ls_output =  lv_date_msg.
              APPEND ls_output TO lt_output.
              CLEAR ls_output.
              RETURN.

          ENDTRY.

          CLEAR lv_sql_stmt.
          " Building query to fetch n large tables

          CONCATENATE
'SELECT SQ_EXC_AGGR.HOST AS HOST ,'
' SQ_EXC_AGGR.PORT AS PORT ,'
' SQ_EXC_AGGR.SCHEMA_NAME AS SCHEMA_NAME ,'
' SQ_EXC_AGGR.TABLE_NAME AS TABLE_NAME ,'
' SQ_EXC_AGGR.PART_ID AS PART_ID ,'
' SQ_EXC_AGGR.SNAPSHOT_ID AS SNAPSHOT_ID ,'
' SQ_EXC_AGGR.MEMORY_SIZE_IN_TOTAL AS MEMORY_SIZE_IN_TOTAL ,'
' SQ_EXC_AGGR.MEMORY_SIZE_IN_MAIN AS MEMORY_SIZE_IN_MAIN ,'
' SQ_EXC_AGGR.MEMORY_SIZE_IN_DELTA AS MEMORY_SIZE_IN_DELTA ,'
' SQ_EXC_AGGR.MEMORY_SIZE_IN_HISTORY_MAIN AS'
' MEMORY_SIZE_IN_HISTORY_MAIN ,'
' MEMORY_SIZE_IN_HISTORY_DELTA ,'
' SQ_EXC_AGGR.ESTIMATED_MAX_MEMORY_SIZE_IN_TOTAL AS'
' ESTIMATED_MAX_MEMORY_SIZE_IN_TOTAL ,'
' SQ_EXC_AGGR.RECORD_COUNT AS RECORD_COUNT ,'
' SQ_EXC_AGGR.RAW_RECORD_COUNT_IN_MAIN AS RAW_RECORD_COUNT_IN_MAIN ,'
' SQ_EXC_AGGR.RAW_RECORD_COUNT_IN_DELTA AS'
' RAW_RECORD_COUNT_IN_DELTA ,'
' SQ_EXC_AGGR.RAW_RECORD_COUNT_IN_HISTORY_MAIN AS'
' RAW_RECORD_COUNT_IN_HISTORY_MAIN ,'
' SQ_EXC_AGGR.RAW_RECORD_COUNT_IN_HISTORY_DELTA AS'
' RAW_RECORD_COUNT_IN_HISTORY_DELTA ,'
' SQ_EXC_AGGR.LAST_COMPRESSED_RECORD_COUNT AS'
' LAST_COMPRESSED_RECORD_COUNT ,'
' SQ_EXC_AGGR.IS_DELTA_LOADED_B AS IS_DELTA_LOADED_B ,'
' SQ_EXC_AGGR.LOADED AS LOADED ,'
' SQ_EXC_AGGR.LAST_MERGE_TIME AS LAST_MERGE_TIME ,'
' SQ_EXC_AGGR.LOCATION AS LOCATION ,'
' 0.0 AS PART_COUNT ,'
' 0.0 AS TABLE_COLUMN_COUNT ,'
' SQ_EXC_AGGR.CREATE_TIME AS CREATE_TIME ,'
' SQ_EXC_AGGR.IS_LOG_DELTA_B AS IS_LOG_DELTA_B ,'
' SQ_EXC_AGGR.LAST_ESTIMATED_MEMORY_SIZE AS '
' LAST_ESTIMATED_MEMORY_SIZE ,'
' SQ_EXC_AGGR.LAST_ESTIMATED_MEMORY_SIZE_TIME AS'
' LAST_ESTIMATED_MEMORY_SIZE_TIME ,'
' SQ_EXC_AGGR.LAST_REPLAY_LOG_TIME AS LAST_REPLAY_LOG_TIME ,'
' SQ_EXC_AGGR.LAST_TRUNCATION_TIME AS LAST_TRUNCATION_TIME ,'
' SQ_EXC_AGGR.MAX_UDIV AS MAX_UDIV ,'
' SQ_EXC_AGGR.MERGE_COUNT AS MERGE_COUNT ,'
' SQ_EXC_AGGR.MODIFY_TIME AS MODIFY_TIME ,'
' SQ_EXC_AGGR.PERSISTENT_MERGE_B AS PERSISTENT_MERGE_B ,'
' SQ_EXC_AGGR.READ_COUNT AS READ_COUNT ,'
' SQ_EXC_AGGR.SERVER_TIMESTAMP AS SERVER_TIMESTAMP ,'
' SQ_EXC_AGGR.UNUSED_RETENTION_PERIOD AS UNUSED_RETENTION_PERIOD ,'
' SQ_EXC_AGGR.WRITE_COUNT AS WRITE_COUNT'
' FROM (SELECT CREATE_TIME ,'
' HOST ,'
' IS_DELTA_LOADED_B ,'
' IS_LOG_DELTA_B ,'
' LOADED ,'
' LOCATION ,'
' MAX(ESTIMATED_MAX_MEMORY_SIZE_IN_TOTAL) AS'
' ESTIMATED_MAX_MEMORY_SIZE_IN_TOTAL ,'
' MAX(LAST_COMPRESSED_RECORD_COUNT) AS'
' LAST_COMPRESSED_RECORD_COUNT ,'
' MAX(LAST_ESTIMATED_MEMORY_SIZE) AS'
' LAST_ESTIMATED_MEMORY_SIZE ,'
' MAX(LAST_ESTIMATED_MEMORY_SIZE_TIME) AS'
' LAST_ESTIMATED_MEMORY_SIZE_TIME ,'
' MAX(LAST_MERGE_TIME) AS LAST_MERGE_TIME ,'
' MAX(LAST_REPLAY_LOG_TIME) AS LAST_REPLAY_LOG_TIME ,'
' MAX(LAST_TRUNCATION_TIME) AS LAST_TRUNCATION_TIME ,'
' MAX(MAX_UDIV) AS MAX_UDIV ,'
' MAX(MEMORY_SIZE_IN_DELTA) AS MEMORY_SIZE_IN_DELTA ,'
' MAX(MEMORY_SIZE_IN_HISTORY_DELTA) AS'
' MEMORY_SIZE_IN_HISTORY_DELTA ,'
' MAX(MEMORY_SIZE_IN_HISTORY_MAIN) AS'
' MEMORY_SIZE_IN_HISTORY_MAIN ,'
' MAX(MEMORY_SIZE_IN_MAIN) AS MEMORY_SIZE_IN_MAIN ,'
' MAX(MEMORY_SIZE_IN_TOTAL) AS MEMORY_SIZE_IN_TOTAL ,'
' MAX(MERGE_COUNT) AS MERGE_COUNT ,'
' MAX(RAW_RECORD_COUNT_IN_DELTA) AS RAW_RECORD_COUNT_IN_DELTA ,'
' MAX(RAW_RECORD_COUNT_IN_HISTORY_DELTA) AS'
' RAW_RECORD_COUNT_IN_HISTORY_DELTA ,'
' MAX(RAW_RECORD_COUNT_IN_HISTORY_MAIN) AS'
' RAW_RECORD_COUNT_IN_HISTORY_MAIN ,'
' MAX(RAW_RECORD_COUNT_IN_MAIN) AS RAW_RECORD_COUNT_IN_MAIN ,'
' MAX(READ_COUNT) AS READ_COUNT ,'
' MAX(RECORD_COUNT) AS RECORD_COUNT ,'
' MAX(UNUSED_RETENTION_PERIOD) AS UNUSED_RETENTION_PERIOD ,'
' MAX(WRITE_COUNT) AS WRITE_COUNT ,'
' MODIFY_TIME ,'
' PART_ID ,'
' PERSISTENT_MERGE_B ,'
' PORT ,'
' SCHEMA_NAME ,'
' SERVER_TIMESTAMP ,'
' SNAPSHOT_ID ,'
' TABLE_NAME'
' FROM (SELECT CASE HOST_COLUMN_TABLES_PART_SIZE.IS_DELTA_LOADED'
' WHEN '
''''
'TRUE'
''''
' THEN '
''''
'X'
''''
' WHEN '
''''
'FALSE'
''''
' THEN '
''''
''
''''
' ELSE '
''''
'-'
''''
' END AS IS_DELTA_LOADED_B ,'
' CASE HOST_COLUMN_TABLES_PART_SIZE.IS_LOG_DELTA WHEN '
''''
'TRUE'
''''
' THEN '
''''
'X'
''''
' WHEN '
''''
'FALSE'
''''
' THEN '
''''
''
''''
' ELSE '
''''
'-'
''''
' END AS IS_LOG_DELTA_B ,'
' CASE HOST_COLUMN_TABLES_PART_SIZE.PERSISTENT_MERGE WHEN '
''''
'TRUE'
''''
' THEN '
''''
'X'
''''
' WHEN '
''''
'FALSE'
''''
' THEN '
''''
''
''''
' ELSE '
''''
'-'
''''
' END AS PERSISTENT_MERGE_B ,'
' HOST_COLUMN_TABLES_PART_SIZE.CREATE_TIME AS CREATE_TIME ,'
' HOST_COLUMN_TABLES_PART_SIZE.HOST AS HOST ,'
' HOST_COLUMN_TABLES_PART_SIZE.LOADED AS LOADED ,'
' HOST_COLUMN_TABLES_PART_SIZE.MODIFY_TIME AS MODIFY_TIME ,'
' HOST_COLUMN_TABLES_PART_SIZE.PART_ID AS PART_ID ,'
' HOST_COLUMN_TABLES_PART_SIZE.PORT AS PORT ,'
' HOST_COLUMN_TABLES_PART_SIZE.SCHEMA_NAME AS SCHEMA_NAME ,'
' HOST_COLUMN_TABLES_PART_SIZE.SERVER_TIMESTAMP AS'
' SERVER_TIMESTAMP ,'
' HOST_COLUMN_TABLES_PART_SIZE.SNAPSHOT_ID AS SNAPSHOT_ID ,'
' HOST_COLUMN_TABLES_PART_SIZE.TABLE_NAME AS TABLE_NAME ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.ESTIMATED_MAX_MEMORY_SIZE_IN_TOTAL)'
' AS ESTIMATED_MAX_MEMORY_SIZE_IN_TOTAL ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.LAST_COMPRESSED_RECORD_COUNT) '
' AS LAST_COMPRESSED_RECORD_COUNT ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.LAST_ESTIMATED_MEMORY_SIZE) '
' AS LAST_ESTIMATED_MEMORY_SIZE ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.LAST_ESTIMATED_MEMORY_SIZE_TIME) '
' AS LAST_ESTIMATED_MEMORY_SIZE_TIME ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.LAST_MERGE_TIME) '
' AS LAST_MERGE_TIME ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.LAST_REPLAY_LOG_TIME) '
' AS LAST_REPLAY_LOG_TIME ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.LAST_TRUNCATION_TIME) '
' AS LAST_TRUNCATION_TIME ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.MAX_UDIV) AS MAX_UDIV ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.MEMORY_SIZE_IN_DELTA) '
' AS MEMORY_SIZE_IN_DELTA ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.MEMORY_SIZE_IN_HISTORY_DELTA) '
' AS MEMORY_SIZE_IN_HISTORY_DELTA ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.MEMORY_SIZE_IN_HISTORY_MAIN) '
' AS MEMORY_SIZE_IN_HISTORY_MAIN ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.MEMORY_SIZE_IN_MAIN)'
' AS MEMORY_SIZE_IN_MAIN ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.MEMORY_SIZE_IN_TOTAL) '
' AS MEMORY_SIZE_IN_TOTAL ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.MERGE_COUNT) '
' AS MERGE_COUNT ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.RAW_RECORD_COUNT_IN_DELTA)'
' AS RAW_RECORD_COUNT_IN_DELTA ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.RAW_RECORD_COUNT_IN_HISTORY_DELTA)'
' AS RAW_RECORD_COUNT_IN_HISTORY_DELTA ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.RAW_RECORD_COUNT_IN_HISTORY_MAIN)'
' AS RAW_RECORD_COUNT_IN_HISTORY_MAIN ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.RAW_RECORD_COUNT_IN_MAIN)'
' AS RAW_RECORD_COUNT_IN_MAIN ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.READ_COUNT)'
' AS READ_COUNT ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.RECORD_COUNT)'
' AS RECORD_COUNT ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.UNUSED_RETENTION_PERIOD)'
' AS UNUSED_RETENTION_PERIOD ,'
' MAX(HOST_COLUMN_TABLES_PART_SIZE.WRITE_COUNT)'
' AS WRITE_COUNT ,'
' M_TABLE_LOCATIONS.LOCATION AS LOCATION'
' FROM _SYS_STATISTICS.HOST_COLUMN_TABLES_PART_SIZE AS'
' HOST_COLUMN_TABLES_PART_SIZE LEFT OUTER JOIN SYS.M_TABLE_LOCATIONS'
' AS M_TABLE_LOCATIONS'
' ON HOST_COLUMN_TABLES_PART_SIZE.SCHEMA_NAME = '
' M_TABLE_LOCATIONS.SCHEMA_NAME AND'
' HOST_COLUMN_TABLES_PART_SIZE.TABLE_NAME = '
' M_TABLE_LOCATIONS.TABLE_NAME AND'
' HOST_COLUMN_TABLES_PART_SIZE.PART_ID ='
' M_TABLE_LOCATIONS.PART_ID AND'
' HOST_COLUMN_TABLES_PART_SIZE.PORT ='
' M_TABLE_LOCATIONS.PORT AND'
' HOST_COLUMN_TABLES_PART_SIZE.HOST = M_TABLE_LOCATIONS.HOST'
' WHERE HOST_COLUMN_TABLES_PART_SIZE.SNAPSHOT_ID >= TO_TIMESTAMP( ? )'
' AND'
' HOST_COLUMN_TABLES_PART_SIZE.SNAPSHOT_ID <= TO_TIMESTAMP( ? )'
' GROUP BY HOST_COLUMN_TABLES_PART_SIZE.HOST ,'
' HOST_COLUMN_TABLES_PART_SIZE.PORT ,'
' HOST_COLUMN_TABLES_PART_SIZE.SCHEMA_NAME ,'
' HOST_COLUMN_TABLES_PART_SIZE.TABLE_NAME ,'
' HOST_COLUMN_TABLES_PART_SIZE.PART_ID ,'
' HOST_COLUMN_TABLES_PART_SIZE.SNAPSHOT_ID ,'
' CASE HOST_COLUMN_TABLES_PART_SIZE.IS_DELTA_LOADED WHEN '
''''
'TRUE'
''''
' THEN '
''''
'X'
''''
' WHEN '
''''
'FALSE'
''''
' THEN '
''''
''
''''
' ELSE '
''''
'-'
''''
' END ,'
' HOST_COLUMN_TABLES_PART_SIZE.LOADED ,'
' M_TABLE_LOCATIONS.LOCATION ,'
' HOST_COLUMN_TABLES_PART_SIZE.CREATE_TIME ,'
' CASE HOST_COLUMN_TABLES_PART_SIZE.IS_LOG_DELTA WHEN '
''''
'TRUE'
''''
' THEN '
''''
'X'
''''
' WHEN '
''''
'FALSE'
''''
' THEN '
''''
''
''''
' ELSE '
''''
'-'
''''
' END ,'
' HOST_COLUMN_TABLES_PART_SIZE.MODIFY_TIME ,'
' CASE HOST_COLUMN_TABLES_PART_SIZE.PERSISTENT_MERGE WHEN '
''''
'TRUE'
''''
' THEN '
''''
'X'
''''
' WHEN '
''''
'FALSE'
''''
' THEN '
''''
''
''''
' ELSE '
''''
'-'
''''
' END ,'
' HOST_COLUMN_TABLES_PART_SIZE.SERVER_TIMESTAMP ) '
' AS SQ_STD_AGGR'
' GROUP BY HOST ,'
' PORT ,'
' SCHEMA_NAME ,'
' TABLE_NAME ,'
' PART_ID ,'
' SNAPSHOT_ID ,'
' IS_DELTA_LOADED_B ,'
' LOADED ,'
' LOCATION ,'
' CREATE_TIME ,'
' IS_LOG_DELTA_B ,'
' MODIFY_TIME ,'
' PERSISTENT_MERGE_B ,'
' SERVER_TIMESTAMP ) AS SQ_EXC_AGGR'
' ORDER BY MEMORY_SIZE_IN_TOTAL DESC'
' LIMIT '
lv_num_tab
INTO lv_sql_stmt RESPECTING BLANKS.

          TRY.
              " Here we get the large tables
              lr_set = lr_stmt_ref->execute_query( lv_sql_stmt ).

*   Begin of changes in V001
              lt_metadata = lr_set->get_metadata( ).
              lr_metadata = lr_set->get_struct_ref( md_tab = lt_metadata
                                                p_strict = abap_false ).

              ex_structdescr ?=
              cl_abap_typedescr=>describe_by_data_ref( lr_metadata ).

              lr_tabletype =
              cl_abap_tabledescr=>create( p_line_type  = ex_structdescr
              p_table_kind = cl_abap_tabledescr=>tablekind_std ).

              CREATE DATA ex_result_ref TYPE HANDLE lr_tabletype.
              lr_structdescr ?=
              cl_abap_typedescr=>describe_by_data_ref( lr_metadata ).

              CREATE DATA lr_structure TYPE HANDLE lr_structdescr.
              ASSIGN lr_structure->* TO <fs_structure>.

              lr_set->set_param_table( itab_ref = ex_result_ref ).
              lr_set->next_package( ).

              ASSIGN ex_result_ref->* TO <fs_table>.

              " Catch exception if any while fetching large tables
            CATCH cx_sql_exception INTO lr_sql_excp.
              lv_exe_msg = lr_sql_excp->get_text( ).
              ls_output = lv_exe_msg.
              APPEND ls_output TO lt_output.
              CLEAR: lv_exe_msg, ls_output.
              RETURN.
          ENDTRY.

          " Moving captured data to lt_table
          MOVE-CORRESPONDING <fs_table> TO lt_table.

*   End of changes in V001


*   Begin of changes in V002
*   Deleting entries based on input schema
          IF lt_table IS NOT INITIAL.

            SORT lt_table BY schema_name.
            lt_table_tmp[] = lt_table[].

            FREE: lt_table[].

            LOOP AT lt_schema INTO ls_schema.
              lt_table_tmp1[] = lt_table_tmp[].
              DELETE lt_table_tmp1[] WHERE schema_name NE ls_schema.
              APPEND LINES OF lt_table_tmp1[] TO lt_table[].
              CLEAR: ls_schema.
            ENDLOOP.

            SORT lt_table BY memory_size_in_total DESCENDING.

            DELETE lt_table FROM lv_count.
          ENDIF.
*   End of changes in V002

          IF lt_table IS NOT INITIAL.

            CREATE OBJECT lr_convert
              EXPORTING
                dbcname = lv_con_name.

            " Adding heading to the output
            CONCATENATE lc_schema         lc_sep          "+V002
                        lc_table_name     lc_sep
                        lc_size           lc_sep
                        lc_no_rows
                        INTO ls_output.
            APPEND ls_output TO lt_output.
            CLEAR ls_output.

            LOOP AT lt_table INTO ls_table.
* Begin of changes in V003
              IF ls_table-record_count IS INITIAL.
                ls_table-record_count = lc_null.
              ENDIF.
* End of changes in V003

              lv_size = ls_table-memory_size_in_total.

              " Method to convert bytes into Kilobytes
              CALL METHOD lr_convert->convert_byte_into_kb
                CHANGING
                  val = lv_size.

              lv_msintotal    = lv_size.

*   Begin of changes in V001
              CONDENSE: lv_msintotal, ls_table-record_count.

              CONCATENATE ls_table-schema_name     lc_sep    "+V002
                          ls_table-table_name      lc_sep
                          lv_msintotal             lc_sep
                          ls_table-record_count
                          INTO ls_output.
              APPEND ls_output TO lt_output.
              CLEAR: ls_output, lv_msintotal, lv_size, ls_table.
*   End of changes in V001
            ENDLOOP.

          ELSE.

            " No records found
            ls_output = lc_err_msg.
            APPEND ls_output TO lt_output.
            CLEAR ls_output.
          ENDIF.

        CATCH cx_sql_exception INTO lr_sql_excp.
          lv_con_msg = lr_sql_excp->get_text( ).
          ls_output = lv_con_msg.
          APPEND ls_output TO lt_output.
          CLEAR ls_output.
          RETURN.
      ENDTRY.
* Begin of changes in V003
      "Adding NULL values in between
      DO.
        REPLACE ALL OCCURRENCES OF SUBSTRING '||'
        IN TABLE lt_output WITH '|NULL|'.
        FIND '||' IN TABLE lt_output.
        IF sy-subrc <> 0.
          EXIT .
        ENDIF.
      ENDDO.
*   End of changes in V003
*   Begin of changes in V001
    WHEN OTHERS.
      " Incorrect input
      ls_output = lc_inc_input.
      APPEND ls_output TO lt_output.
      CLEAR ls_output.
*   End of changes in V001
  ENDCASE.

ENDFORM.