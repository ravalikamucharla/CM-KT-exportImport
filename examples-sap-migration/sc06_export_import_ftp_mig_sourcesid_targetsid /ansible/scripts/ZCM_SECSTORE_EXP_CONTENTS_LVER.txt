*---------------------------------------------------------------------*
* Program Name        :   ZCM_SECSTORE_EXP_CONTENTS_LVER              *
* Title               :   Secure storage content Export               *
* Purpose             :   This report is used to export secure        *
*                     :   storage contents from tcode SECSTORE        *
*                     :   pre migration. The functionality is taken   *
*                         from RSECADMIN( main check).                *
*---------------------------------------------------------------------*
* Related Transaction OR Standard Program References                  *
* SECSTORE                                                            *
*---------------------------------------------------------------------*
* Tables              :   SELECT    UPDATE      INSERT      DELETE    *
* XXXXX                     X                                         *
*---------------------------------------------------------------------*
* Program Change History                                              *
*---------------------------------------------------------------------*
*Date        Version     Author     TR#/Local     Description         *
*---------------------------------------------------------------------*
*01-10-2023  Initial   Soumya Ray   Local       To export secstore    *
*                                               data                  *
*---------------------------------------------------------------------*

REPORT zcm_secstore_exp_contents_lver.

LOAD-OF-PROGRAM.
  CONSTANTS:
    con_int_retcode_2 TYPE i VALUE 2.

  TYPES:
* Lookup table for handlers
    BEGIN OF ty_s_handler_lookup,
      handler_id           TYPE rsec_handler_id,
      handler              TYPE REF TO if_secstore_handler,
      appl_descr           TYPE rsec_appl_descr,
      cross_client_details TYPE abap_bool,
      cross_client_check   TYPE abap_bool,
    END OF ty_s_handler_lookup,

* Lookup table for prefixes
    BEGIN OF ty_s_prefix_lookup,
      prefix     TYPE rsecprefix,
      prefix_len TYPE i,
      class_name TYPE string,
      handler_id TYPE rsec_handler_id,
      has_error  TYPE char1,
    END OF ty_s_prefix_lookup,
    BEGIN OF ty_s_prefinal,
      msgtyp   TYPE char1,
      mandt    TYPE mandt,
      ident    TYPE rsecid,
      msg      TYPE string,
      tstampdt TYPE sydatum,
      tstamptm TYPE syuzeit,
      clindep  TYPE rsecclindep,
    END OF ty_s_prefinal.

  DATA:
    gt_handler_lookup      TYPE HASHED TABLE OF
    ty_s_handler_lookup WITH UNIQUE KEY handler_id,
    gt_prefix_lookup       TYPE TABLE OF ty_s_prefix_lookup,
    gf_message_dummy       TYPE string.

*----------------------------------------------------------------------*
*       CLASS lcl_generic_handler DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_generic_handler DEFINITION FINAL.
  PUBLIC SECTION.
    INTERFACES if_secstore_handler_711.
ENDCLASS.                    "lcl_generic_handler DEFINITION
*----------------------------------------------------------------------*
*       CLASS lcl_generic_handler IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_generic_handler IMPLEMENTATION.

*----------------------------------------------------------------------
* Get header data for the records handled by this handler.
*----------------------------------------------------------------------
  METHOD if_secstore_handler~get_application_details.
    ef_description          = 'Others'(001).
    ef_cross_client_details = abap_true.
    ef_cross_client_check   = abap_false.
  ENDMETHOD.             "if_secstore_handler~get_application_details
*----------------------------------------------------------------------
* Get record details.
* The generic handler can only tell some general things
*----------------------------------------------------------------------
  METHOD if_secstore_handler~get_record_details.

* Navigation not supported (to where should it go?)
    ef_navigation_supported = abap_false.

* Create description according to the known prefixes of the
* applications. This is just a workaround for applications that
* did not implement the BAdI.
* Note: As this handler is called for unknown namespaces,
* the PREFIX part is empty and the complete name is part of
* the IDPART field.
    DATA:
          lf_appl TYPE rsec_record_descr.

    IF     if_identpart(14) = 'BC_SECSTORE01_' OR
    if_identpart(17) = 'BC_CI_SECSTORE01_'.
      lf_appl = 'Report SECSTORE01'(024).
    ELSEIF if_identpart(7) = 'BC_INIT'.
      lf_appl = 'Internal initialization record'(025).
    ELSEIF if_identpart(17) = 'BC_SECSTORE_TEST_'.
      lf_appl = 'ABAP-Unit test records'(026) .
    ELSEIF if_identpart(08) = 'BC_LDAP_'.
      lf_appl = 'LDAP System User'(027) .
    ELSEIF if_identpart(04) = 'FTR_'.
      lf_appl = 'Financial Services'.
    ELSEIF if_identpart(12) = 'XI_SECURITY_'.
      lf_appl = 'XI Password Cache'.
    ELSEIF if_identpart(06) = 'BC_SX_'.
      lf_appl = 'SAP Connect'.
    ELSEIF if_identpart(07) = 'BC_SPH_'.
      lf_appl = 'SAP Phone'.
    ELSEIF if_identpart(15) = 'BC_WSS_PROFILE_'.
      lf_appl = 'Web Services Security'.
    ELSEIF if_identpart(11) = 'GBEFIUSERID' OR
      if_identpart(13) = 'GBEFIPASSWORD'.
      lf_appl = 'Great Britain Tax'.
    ELSEIF if_identpart(04) = 'MDM_'.
      lf_appl = 'Master Data Management'.
    ELSEIF if_identpart(05) = 'FTPPw'            OR
      if_identpart(16) = 'FTP_BOX_PASSWORD' OR
      if_identpart(16) = 'Meeting/Password'.
      lf_appl = 'cFolders'.
    ELSEIF if_identpart(11) = '/CCMS/GRMG/'.
      lf_appl = 'CCMS Generic Request Monitor Generator'.
    ELSEIF if_identpart(7) = '/PIQGB/'.
      lf_appl = 'Campus Management GB'.
    ENDIF.

    IF NOT lf_appl IS INITIAL.
      CONCATENATE
      lf_appl
      ':'
      if_identpart
      INTO
      ef_description
      SEPARATED BY space.
    ELSE.
      ef_description = if_identpart.
    ENDIF.

  ENDMETHOD.                    "if_secstore_handler~get_record_details

*---------------------------------------------------------------------
* Check a record.
* For these records, nothing can be checked because this is a generic
* handler that does not know anything about the records it is called
* for.
* But we allow that the record can be deleted. If the application did
* did not care to create its own handler, it has no right of record
* protection.
*---------------------------------------------------------------------
  METHOD if_secstore_handler~check_record.
  ENDMETHOD.                    "if_secstore_handler~check_record

*---------------------------------------------------------------------
* Navigation to a record.
* As all records declare they are not navigatable (GET_RECORD_DETAILS),
* this method will never be called and so does not need to do anything.
*----------------------------------------------------------------------
  METHOD if_secstore_handler~navigate_to_record.
  ENDMETHOD.                    "if_secstore_handler~navigate_to_record

*---------------------------------------------------------------------
* Deletion of record.
* Default handler: Nothing to do, nothing to say.
*---------------------------------------------------------------------
  METHOD if_secstore_handler_710~delete_record_notify.
  ENDMETHOD.            "if_secstore_handler_710~delete_record_notify

ENDCLASS.              "lcl_generic_handler IMPLEMENTATION

FORM get_config
               TABLES ft_input  STRUCTURE tab512
                      ft_output STRUCTURE tab512.

  CONSTANTS: lc_sep       TYPE c VALUE '|'                    LENGTH 1,
             lc_act_exp   TYPE c VALUE 'EXPORT'               LENGTH 6,
             lc_id        TYPE c VALUE 'Recordid'             LENGTH 8,
             lc_date      TYPE c VALUE 'Systemdate'           LENGTH 10,
             lc_time      TYPE c VALUE 'Systemtime'           LENGTH 10,
             lc_client    TYPE c VALUE 'Crossclientindicator' LENGTH 20,
             lc_msg1      TYPE c VALUE 'Message'              LENGTH 7,
             lc_msgtyp    TYPE c VALUE 'Messagetype'          LENGTH 11,
             lc_mandt     TYPE c VALUE 'Client'               LENGTH 6,
             lc_title     TYPE c VALUE 'Secure storage data'  LENGTH 30,
             lc_msg       TYPE c VALUE 'No data found'        LENGTH 20,
             lc_inc_input TYPE c VALUE 'Incorrect input'      LENGTH 20,
             lc_noinput   TYPE c VALUE 'No input given'       LENGTH 20.
  DATA: lt_prefinal TYPE TABLE OF ty_s_prefinal,
        ls_input    TYPE tab512,
        ls_output   TYPE tab512,
        lv_action   TYPE char8.

  FIELD-SYMBOLS: <field>       TYPE any,
                 <fs_prefinal> TYPE ty_s_prefinal.
  CLEAR: ls_input,
  lv_action.

  " Tile
  CLEAR: ls_output.
  ls_output = lc_title.
  APPEND ls_output TO ft_output.

  " Read input values from Python
  READ TABLE ft_input INTO ls_input INDEX 1.
  IF sy-subrc NE 0.
    " No input given
    ls_output = lc_noinput.
    APPEND ls_output TO ft_output.
    CLEAR ls_output.
    RETURN.
  ENDIF.
  lv_action = ls_input.

  PERFORM init.
  CASE lv_action.

    WHEN lc_act_exp.
      PERFORM main TABLES lt_prefinal.
      IF lt_prefinal IS INITIAL.
        CLEAR: ls_output.
        ls_output = lc_msg.
        APPEND ls_output TO ft_output.
        RETURN.
      ELSE.
        SORT: lt_prefinal BY ident.
      ENDIF.

      " Heading Columns
      CLEAR: ls_output.
      CONCATENATE lc_msgtyp lc_sep
      lc_mandt  lc_sep
      lc_id     lc_sep
      lc_msg1   lc_sep
      lc_date   lc_sep
      lc_time   lc_sep
      lc_client
      INTO ls_output.
      APPEND ls_output TO ft_output.

      LOOP AT lt_prefinal ASSIGNING <fs_prefinal>.

        DO.
          ASSIGN COMPONENT sy-index
          OF STRUCTURE <fs_prefinal> TO <field>.
          CONDENSE <field>.

          IF sy-subrc <> 0.
            EXIT.
          ENDIF.

          IF <field> IS INITIAL.
            <field> = 'NULL'.
          ENDIF.

          IF sy-index EQ 1.
            ls_output = <field>.
          ELSE.
            CONCATENATE ls_output <field> INTO ls_output
            SEPARATED BY lc_sep.
          ENDIF.
        ENDDO.

        CONDENSE ls_output.
        APPEND ls_output TO ft_output.
        CLEAR: ls_output.
      ENDLOOP.
    WHEN OTHERS.
      " Incorrect input
      ls_output = lc_inc_input.
      APPEND ls_output TO ft_output.
      CLEAR ls_output.
  ENDCASE.
ENDFORM.                    "get_config

*&---------------------------------------------------------------------*
*&      Form  init
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM init .

  DATA:
    lo_badi               TYPE REF TO if_ex_secstore_application,
    lt_reg                TYPE secstore_registration_t,
    ls_generic_handler    TYPE ty_s_handler_lookup,
    ls_reg                TYPE secstore_registration,
    ls_prefix             TYPE ty_s_prefix_lookup,
    lo_object             TYPE REF TO cl_abap_objectdescr,
    lf_handler_id_counter TYPE rsec_handler_id,
    ls_handler_found      TYPE ty_s_handler_lookup.


  CALL METHOD cl_exithandler=>get_instance
    EXPORTING
      exit_name                     = 'SECSTORE_APPLICATION'
      null_instance_accepted        = 'X'
    CHANGING
      instance                      = lo_badi
    EXCEPTIONS
      no_reference                  = 1
      no_interface_reference        = 2
      no_exit_interface             = 3
      class_not_implement_interface = 4
      single_exit_multiply_active   = 5
      cast_error                    = 6
      exit_not_existing             = 7
      data_incons_in_exit_managem   = 8
      OTHERS                        = 9.
  IF sy-subrc <> 0.
    CLEAR lo_badi.
  ENDIF.

* Get handlers from the BAdI implementers
  IF NOT lo_badi IS INITIAL.
    CALL METHOD lo_badi->register_prefix
      CHANGING
        ct_prefixes = lt_reg.
  ENDIF.

* Empty handler classes are irrelevant
  DELETE lt_reg WHERE if_handler IS INITIAL.

* Insert generic handler with ID 0000
  CLEAR ls_generic_handler-handler_id.
  CREATE OBJECT ls_generic_handler-handler
    TYPE lcl_generic_handler.
  CALL METHOD ls_generic_handler-handler->get_application_details
    IMPORTING
      ef_description          = ls_generic_handler-appl_descr
      ef_cross_client_details = ls_generic_handler-cross_client_details
      ef_cross_client_check   = ls_generic_handler-cross_client_check.
  INSERT ls_generic_handler INTO TABLE gt_handler_lookup.

* Sort by prefix to have a stable order for the order of handlers
* (these determine the sorting order shown in the tree).
  SORT lt_reg BY prefix.

  LOOP AT lt_reg INTO ls_reg.

*   Check whether this handler is already known

    LOOP AT gt_handler_lookup INTO ls_handler_found
    WHERE handler = ls_reg-if_handler.
      EXIT.
    ENDLOOP.

    IF sy-subrc <> 0.
      CLEAR ls_handler_found.
      ADD 1 TO lf_handler_id_counter.
      ls_handler_found-handler_id = lf_handler_id_counter.
      ls_handler_found-handler    = ls_reg-if_handler.
      CALL METHOD ls_reg-if_handler->get_application_details
        IMPORTING
          ef_description          = ls_handler_found-appl_descr
          ef_cross_client_details =
                                  ls_handler_found-cross_client_details
          ef_cross_client_check   = ls_handler_found-cross_client_check.
      INSERT ls_handler_found INTO TABLE gt_handler_lookup.
    ENDIF.

    CLEAR ls_prefix.

    ls_prefix-prefix     = ls_reg-prefix.
    ls_prefix-prefix_len = strlen( ls_reg-prefix ).
    ls_prefix-handler_id = ls_handler_found-handler_id.

*   Class name of implementing class
    lo_object ?= cl_abap_typedescr=>describe_by_object_ref(
    ls_reg-if_handler ).
    ls_prefix-class_name = lo_object->get_relative_name( ).

    INSERT ls_prefix INTO TABLE gt_prefix_lookup.

  ENDLOOP.


ENDFORM.   " INIT

FORM main TABLES lt_prefinal.

  DATA:
    lt_rsectab               TYPE TABLE OF rsectab,
    l_msgtyp                 TYPE char1,
    ls_prefinal              TYPE ty_s_prefinal,
    lt_rsecactb              TYPE SORTED TABLE OF rsecactb
                               WITH NON-UNIQUE KEY ident,
    ls_rsecactb              TYPE rsecactb,
    ls_rsectab               TYPE rsectab,
    ls_context               TYPE rsec_bal_context,
    ls_sy                    TYPE sy,
    lf_data                  TYPE rsecdata,
    lt_rsecabac              TYPE rsecabac_t,
    lf_newident              TYPE rsecid,
    lf_val                   TYPE i,
    ls_rsecabac              TYPE rsecabac,
    lf_error_occurred        TYPE abap_bool,
    lf_appl_msg_sent         TYPE abap_bool,
    lf_prefix                TYPE rsecprefix,
    lf_identpart             TYPE rsecidpart,
    ls_bapiret2              TYPE bapiret2,
    lf_stdmsg                TYPE symsgno,
    lt_bapiret2              TYPE bapirettab.

*Select records from RSECACTB of specified fields to get the status
* and messages of the records.
  SELECT
  *
  FROM
  rsectab CLIENT SPECIFIED
  INTO CORRESPONDING FIELDS OF
  TABLE lt_rsectab.

* Select records from RSECACTB to be able to supply the
* check methods with access control data.
  SELECT
  *
  FROM
  rsecactb
  INTO
  TABLE lt_rsecactb.
*
**   Sort records by ident and client in this order for
**   efficient binary search access.
  SORT lt_rsectab BY ident mandt.

* The order of entries in the message list is completely defined by the
* sort flags of the application log. Sorting here only to assist
* debugging purposes.
  SORT lt_rsectab BY clindep DESCENDING
  mandt   ASCENDING
  ident   ASCENDING.

* Begin of record processing
  LOOP AT lt_rsectab INTO ls_rsectab.

*   Get context data for this record
    PERFORM get_context
    USING
          ls_rsectab  " = is_rsectab
    CHANGING
      ls_context. " = cs_context

*   Call test function of the kernel
*   No migration intention here
    CLEAR lf_data.
    CLEAR sy-msgty.

    CALL 'RSEC_AB_ACCESS'
    ID 'OPCODE'             FIELD 'M'
    ID 'IDENTIFIER'         FIELD ls_rsectab-ident
    ID 'CLIENT'             FIELD ls_rsectab-mandt
    ID 'CLIENT_INDEPENDENT' FIELD ls_rsectab-clindep
    ID 'SECURE_DATA'        FIELD lf_data
    ID 'USE_FULL_RETCODE'   FIELD con_int_retcode_2.

*   Error --> write message, go to next record
    IF sy-subrc <> 0.
      PERFORM get_kernel_message
      USING
            sy      " = is_sy
            ls_rsectab-ident " = if_ident
      CHANGING
        ls_sy.           " = es_sy
      PERFORM message_add
      USING
            ls_context " = is_context
            ls_sy     " = is_sy
      CHANGING ls_prefinal.
      APPEND ls_prefinal TO lt_prefinal.
      CLEAR: ls_prefinal, ls_rsectab, ls_sy.
      CONTINUE.
    ENDIF.

*   Global read test successful.
*   Now check whether access control can be read.

    CLEAR lt_rsecabac.

*   Extract access control data. As the table is SORTED,
*   the part-key loop is efficient.
    CONCATENATE
    ls_rsectab-mandt
    ls_rsectab-ident
    INTO
    lf_newident.

    lf_error_occurred = abap_false.

    LOOP AT lt_rsecactb INTO ls_rsecactb
    WHERE ident = lf_newident.

      lf_val = strlen( ls_rsecactb-repname ).

      CLEAR sy-msgty.

      CALL 'RSEC_AB_ACCESS'
      ID 'OPCODE'             FIELD 'G'
      ID 'CLIENT_INDEPENDENT' FIELD ls_rsectab-clindep
      ID 'CLIENT'             FIELD ls_rsectab-mandt
      ID 'IDENTIFIER'         FIELD ls_rsectab-ident
      ID 'SECURE_DATA'        FIELD ls_rsecactb-repname
      ID 'SECURE_DATA_LEN'    FIELD lf_val
      ID 'USE_FULL_RETCODE'   FIELD con_int_retcode_2.
      IF sy-subrc <> 0.
        PERFORM get_kernel_message
        USING
              sy      " = is_sy
              ls_rsectab-ident " = if_ident
        CHANGING
          ls_sy.           " = es_sy
        PERFORM message_add
        USING
              ls_context " = is_context
              ls_sy     " = is_sy
        CHANGING ls_prefinal.
        APPEND ls_prefinal TO lt_prefinal.
        CLEAR: ls_prefinal, ls_rsectab, ls_sy.
        lf_error_occurred = abap_true.
        EXIT.
      ENDIF.

*     Add entry for this report
      CLEAR ls_rsecabac.

      ls_rsecabac-reportname = ls_rsecactb-repname.
      ls_rsecabac-ab_access  = lf_val.
      INSERT ls_rsecabac INTO TABLE lt_rsecabac.

    ENDLOOP.

*   If error, stop with this record and go to the next one
    IF lf_error_occurred = abap_true.
      CONTINUE.
    ENDIF.

*   Now add the records in old format. If for an identifier
*   already an entry is present, the INSERT will not insert
*   it once again, so the precedence order of the kernel is
*   reflected.
    LOOP AT lt_rsecactb INTO ls_rsecactb
    WHERE ident = ls_rsectab-ident.

      lf_val = strlen( ls_rsecactb-repname ).
      CLEAR sy-msgty.
      CALL 'RSEC_AB_ACCESS'
      ID 'OPCODE'             FIELD 'G'
      ID 'CLIENT_INDEPENDENT' FIELD ls_rsectab-clindep
      ID 'CLIENT'             FIELD ls_rsectab-mandt
      ID 'IDENTIFIER'         FIELD ls_rsectab-ident
      ID 'SECURE_DATA'        FIELD ls_rsecactb-repname
      ID 'SECURE_DATA_LEN'    FIELD lf_val
      ID 'USE_FULL_RETCODE'   FIELD con_int_retcode_2.
      IF sy-subrc <> 0.
        PERFORM get_kernel_message
        USING
              sy       " = is_sy
              ls_rsectab-ident " = if_ident
        CHANGING
          ls_sy.           " = es_sy
        PERFORM message_add
        USING
              ls_context " = is_context
              ls_sy     " = is_sy
        CHANGING ls_prefinal.
        APPEND ls_prefinal TO lt_prefinal.
        CLEAR: ls_prefinal,ls_rsectab, ls_sy.
        lf_error_occurred = abap_true.
        EXIT.
      ENDIF.

*     Add entry for this report
      CLEAR ls_rsecabac.

      ls_rsecabac-reportname = ls_rsecactb-repname.
      ls_rsecabac-ab_access  = lf_val.
      INSERT ls_rsecabac INTO TABLE lt_rsecabac.

    ENDLOOP.

*   If error, stop with this record and go to the next one
    IF lf_error_occurred = abap_true.
      CONTINUE.
    ENDIF.

*   Get handler class
    DATA:
          ls_handler TYPE ty_s_handler_lookup.

    READ TABLE gt_handler_lookup INTO ls_handler
    WITH TABLE KEY handler_id = ls_context-handler_id.

*   If technical test successful, check whether application tests
*   should be done.
*   These are done if handler exists and client mathces, or
*   application can handle cross-client checks.
    IF ( NOT ls_context-handler_id IS INITIAL ) AND
    ( ( ls_context-mandt = sy-mandt ) OR
    ( NOT ls_context-clindep IS INITIAL ) OR
    ( ls_handler-cross_client_check = abap_true )
    ).

*     Split ident
      IF ls_context-prefix_len > 0.
        lf_prefix    = ls_context-ident(ls_context-prefix_len).
      ENDIF.
      lf_identpart = ls_context-ident+ls_context-prefix_len.

*     Perform application tests

      CLEAR:
      lf_stdmsg,
      lt_bapiret2.

      CALL METHOD ls_handler-handler->check_record
        EXPORTING
          if_prefix             = lf_prefix
          if_identpart          = lf_identpart
          if_client_independent = ls_context-clindep
          if_client             = ls_context-mandt
          it_rsecabac           = lt_rsecabac
        IMPORTING
          ef_stdmsg             = lf_stdmsg
          et_bapiret2           = lt_bapiret2.

*     Mark successful call of the check function for the deletion
*     decision. When an error is sent by the application in the
*     BAPIRET2, this is later revised.

*     Ignore standard message about missing access control record
*     when IDENT selection was used, because then the ACTB has
*     not been read at all (reason commented there).
      IF lf_stdmsg = if_secstore_handler=>con_stdmsg_insuff_access.
        CLEAR lf_stdmsg.
      ENDIF.
      DELETE lt_bapiret2
      WHERE
      id     = 'SECSTORE' AND
      number = if_secstore_handler=>con_stdmsg_insuff_access.

*     If application specified a standard message to be send...
      lf_appl_msg_sent = abap_false.

      IF NOT lf_stdmsg IS INITIAL.
        MESSAGE
        ID     'SECSTORE'
        TYPE   'W'
        NUMBER lf_stdmsg
        INTO gf_message_dummy.
        l_msgtyp = 'W'.
*        PERFORM message_add
        lf_appl_msg_sent = abap_true.
      ENDIF.

*     If messages from the application are present, add them
*     to the log.

      LOOP AT lt_bapiret2 INTO ls_bapiret2.
        IF NOT ls_bapiret2-type   IS INITIAL AND
        NOT ls_bapiret2-id     IS INITIAL AND
        NOT ls_bapiret2-number IS INITIAL.
          MESSAGE
          ID     ls_bapiret2-id
          TYPE   ls_bapiret2-type
          NUMBER ls_bapiret2-number
          WITH   ls_bapiret2-message_v1
          ls_bapiret2-message_v2
          ls_bapiret2-message_v3
          ls_bapiret2-message_v4
          INTO gf_message_dummy.
        ELSE.
          MESSAGE e056(secstore)
          WITH
          ls_context-appl_desc
          ls_context-ident(50)
          ls_context-ident+50
          INTO
          gf_message_dummy.
        ENDIF.
*       When the message is an error type message, mark this check
*       as not successful, otherwise the default ("successful") stays.
      ENDLOOP.

*     Generic message that technical and application tests OK if
*     nothing sent from application
      IF lf_appl_msg_sent = abap_false.
        MESSAGE s044(secstore) INTO gf_message_dummy.
        l_msgtyp = 'S'.
      ENDIF.

    ELSE.

*     No application tests but technical tests successful
      MESSAGE s043(secstore) INTO gf_message_dummy.
      l_msgtyp = 'S'.

    ENDIF.
    ls_prefinal-mandt  =  ls_context-mandt  .
    ls_prefinal-ident  =  ls_context-ident  .
    ls_prefinal-tstampdt   =  ls_context-tstampdt .
    ls_prefinal-tstamptm   =  ls_context-tstamptm   .
    ls_prefinal-clindep  =  ls_context-clindep  .
    ls_prefinal-msg	 = 	 gf_message_dummy	.
    ls_prefinal-msgtyp = l_msgtyp.
    APPEND ls_prefinal TO lt_prefinal.
    CLEAR: ls_prefinal, l_msgtyp, gf_message_dummy.
  ENDLOOP. " loop RSECTAB records

ENDFORM.                    "main
" MAIN
***********************************************************************
* Get context data from record
***********************************************************************
FORM get_context
USING
      is_rsectab TYPE rsectab
CHANGING
  cs_context TYPE rsec_bal_context.

* Identify the responsible handler according to the record prefix
  DATA:
    ls_prefix     TYPE REF TO ty_s_prefix_lookup,
    lf_handler_id TYPE rsec_handler_id,
    lf_prefix     TYPE rsecprefix,
    lf_identpart  TYPE rsecidpart.

  STATICS:
  lt_t000 TYPE HASHED TABLE OF t000 WITH UNIQUE KEY mandt.

* Prefetch client table
  IF lt_t000 IS INITIAL.
    SELECT
    *
    INTO
    TABLE lt_t000
    FROM
    t000.
  ENDIF.

* At first we do not know the handler. Iniital --> default handler.
  CLEAR:
  lf_handler_id,
  lf_prefix,
  lf_identpart.

* Find matching handler from registration list.
* As long as the prefixes must not be nested into each other,
* the order of GT_PREFIX_LOOKUP is not relevant here. If this changes,
* a stable order of that table is required.
  LOOP AT gt_prefix_lookup REFERENCE INTO ls_prefix.
    IF is_rsectab-ident(ls_prefix->prefix_len) =
    ls_prefix->prefix.
*     For faulty handlers, use the default one
      IF ls_prefix->has_error IS INITIAL.
        lf_handler_id = ls_prefix->handler_id.
      ELSE.
        CLEAR lf_handler_id.
      ENDIF.
      lf_prefix    = ls_prefix->prefix.
      lf_identpart = is_rsectab-ident+ls_prefix->prefix_len.
    ENDIF.
  ENDLOOP.

* If no handler set, fill ident into IDPart.
  IF lf_handler_id IS INITIAL.
    lf_identpart = is_rsectab-ident.
  ENDIF.

* Loop up handler and fill the context data
  DATA:
        ls_handler TYPE ty_s_handler_lookup.

  READ TABLE gt_handler_lookup INTO ls_handler
  WITH TABLE KEY handler_id = lf_handler_id.

  CLEAR cs_context.
  cs_context-mandt      = is_rsectab-mandt.
  cs_context-clindep    = is_rsectab-clindep.
  cs_context-ident      = is_rsectab-ident.
  cs_context-prefix_len = strlen( lf_prefix ).
  cs_context-handler_id = lf_handler_id.
  cs_context-appl_desc  = ls_handler-appl_descr.
  cs_context-tstampdt   = is_rsectab-tstampdt.
  cs_context-tstamptm   = is_rsectab-tstamptm.

* Application can deliver description only under certain
* circumstances...
  CLEAR cs_context-record_desc.

  IF ( is_rsectab-mandt = sy-mandt ) OR
  ( NOT is_rsectab-clindep IS INITIAL ) OR
  ( ls_handler-cross_client_details = abap_true ).
    CALL METHOD ls_handler-handler->get_record_details
      EXPORTING
        if_prefix             = lf_prefix
        if_identpart          = lf_identpart
        if_client_independent = is_rsectab-clindep
        if_client             = is_rsectab-mandt
      IMPORTING
        ef_description        = cs_context-record_desc.
  ENDIF.

* As description appears in tree, it must be filled.
* I handler does not fill it, use final default.
  IF cs_context-record_desc IS INITIAL.
    cs_context-record_desc = is_rsectab-ident.
  ENDIF.

ENDFORM.                    "get_context

************************************************************************
* Map kernel return code to SY-message
************************************************************************
FORM get_kernel_message
USING
      VALUE(is_sy) TYPE sy
      if_ident     TYPE rsecid
CHANGING
  es_sy TYPE sy.

  CLEAR es_sy.

  DATA:
        ls_bapiret2 TYPE bapiret2.

  IF is_sy-msgty IS INITIAL.

    CALL FUNCTION 'SECSTORE_CONVERT_KERNEL_RC'
      EXPORTING
        if_kernel_rc = is_sy-subrc
        if_ident     = if_ident
      IMPORTING
        es_return    = ls_bapiret2.

    es_sy-msgty = ls_bapiret2-type.
    es_sy-msgid = ls_bapiret2-id.
    es_sy-msgno = ls_bapiret2-number.
    es_sy-msgv1 = ls_bapiret2-message_v1.
    es_sy-msgv2 = ls_bapiret2-message_v2.
    es_sy-msgv3 = ls_bapiret2-message_v3.
    es_sy-msgv4 = ls_bapiret2-message_v4.

  ELSE.

*   Kernel has set explicit message --> can be used directly
    MOVE-CORRESPONDING is_sy TO es_sy.

  ENDIF.

ENDFORM.                    "get_kernel_message
************************************************************************
* Add a message to the application log.
************************************************************************
FORM message_add
USING ls_context   TYPE rsec_bal_context
      VALUE(is_sy) TYPE sy
CHANGING ls_prefinal TYPE ty_s_prefinal.

  DATA: ls_msg    TYPE bal_s_msg,
        lv_string TYPE string.

  ls_msg-msgty = is_sy-msgty.
  ls_msg-msgid = is_sy-msgid.
  ls_msg-msgno = is_sy-msgno.
  ls_msg-msgv1 = is_sy-msgv1.
  ls_msg-msgv2 = is_sy-msgv2.
  ls_msg-msgv3 = is_sy-msgv3.
  ls_msg-msgv4 = is_sy-msgv4.

  MESSAGE ID  ls_msg-msgid TYPE ls_msg-msgty NUMBER ls_msg-msgno
  WITH ls_msg-msgv1  ls_msg-msgv2  ls_msg-msgv3 ls_msg-msgv4
  INTO lv_string.

  ls_prefinal-mandt      =  ls_context-mandt.
  ls_prefinal-ident      =  ls_context-ident.
  ls_prefinal-tstampdt   =  ls_context-tstampdt.
  ls_prefinal-tstamptm   =  ls_context-tstamptm.
  ls_prefinal-clindep    =  ls_context-clindep.
  ls_prefinal-msg	       =  lv_string.
  ls_prefinal-msgtyp     =  ls_msg-msgty.


ENDFORM.                    "message_add