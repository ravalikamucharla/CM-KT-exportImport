*---------------------------------------------------------------------*
* Program Name        :  ZCM_SM61_UPD_SERVER_GROUPS                   *
* Title               :  Logical Systems                              *
* Purpose             :  Restore server groups in SM61 in target      *
*                         systems ( Program :BP_SERVER_GROUP) .       *
*                         Program handles creation of new group,      *
*                         instances linked to group, deletion of group*
*                         deletion of instances as per input.         *
*                         For instance processing the methods used in *
*                         class CL_BP_SERVER_GROUP is using direct    *
*                         table manipulation but it can't be called   *
*                     individually. Hence same is replicated in script*
*---------------------------------------------------------------------*
* Related Transaction OR Standard Program References                  *
* SM61                                                                *
*---------------------------------------------------------------------*
* Tables              :   SELECT    UPDATE      INSERT      DELETE    *
* TSRVGRP                   X                                         *
* TSRVLST                   X                                         *
*---------------------------------------------------------------------*
* Program Change History                                              *
*---------------------------------------------------------------------*
*Date        Version   Author       TR#/Local     Description         *
*---------------------------------------------------------------------*
*07-29-2021  Initial  Soumya Ray   Local       To restore server      *
*                                              groups                 *
*09-30-2022  V001     Yasaswini K  Local       To remove dead code    *
*---------------------------------------------------------------------*
REPORT zcm_sm61_upd_server_groups.

CONSTANTS: gc_sep      TYPE c       VALUE '|',
           gc_insert   TYPE c VALUE 'I',
           gc_update   TYPE c VALUE 'U',
           gc_delete   TYPE char2 VALUE 'D',
           gc_msg_head TYPE string VALUE 'Server Group Update',
           gc_nodata   TYPE char30 VALUE 'No changes made',
           gc_subhead  TYPE char30 VALUE 'Group creation error',
           gc_message  TYPE char10 VALUE 'Message',
           gc_group    TYPE char10 VALUE 'Group',
           gc_server   TYPE char10 VALUE 'Server',
           gc_umsg     TYPE string VALUE 'Updated No',
           gc_imsg     TYPE string VALUE 'Inserted No',
           gc_dmsg     TYPE string VALUE 'Deleted No',
           gc_mode     TYPE dd26e-enqmode VALUE 'E',
           gc_tsrvlst  TYPE rstable-tabname VALUE 'TSRVLST',
           gc_grperror TYPE string VALUE ' Error in deleting group:',
           gc_enqueue  TYPE string
                         VALUE 'table failed to lock',
           gc_dequeue  TYPE string
                         VALUE 'table failed to unlock'.


TYPES: BEGIN OF gty_server,
         group    TYPE bpsrvgrp,
         instance TYPE msname2,
       END OF gty_server,
       BEGIN OF gty_group,
         group    TYPE bpsrvgrp,
         instance TYPE msname2,
         status   TYPE c,
         msg      TYPE string,
       END OF gty_group.
DATA: gv_count      TYPE string.

LOAD-OF-PROGRAM.

FORM get_config
TABLES lt_input  STRUCTURE tab512
  lt_output STRUCTURE tab512.

  DATA: ls_output    TYPE tab512,
        lv_tabix     TYPE sy-tabix,
        lt_sub_input TYPE TABLE OF tab512.

  ls_output = gc_msg_head. " Heading of the script
  APPEND ls_output TO lt_output.
  CLEAR: ls_output, lv_tabix.
* Separate the groups (Delete, Insert, Update ) data
  PERFORM table_separate TABLES lt_input
    lt_sub_input
  CHANGING lv_tabix.
* FORM to delete, insert or update group as per the input action
  PERFORM group_processing TABLES lt_sub_input
    lt_output.

  lv_tabix = lv_tabix + 1. " To skip the blank line between tables
  FREE lt_sub_input.
  APPEND ls_output TO lt_output.
* Separate the server(Delete, Insert, Update ) data
  PERFORM table_separate TABLES lt_input
    lt_sub_input
  CHANGING lv_tabix.
* FORM to delete, insert or update server as per the input action
  PERFORM server_processing TABLES lt_sub_input
    lt_output.

ENDFORM.
*// FM to separate the data into tables from the input data
FORM table_separate  TABLES   lt_input STRUCTURE tab512
  lt_sub_input STRUCTURE tab512
CHANGING lv_tabix.

  DATA: ls_input TYPE tab512,
        ls_sub_input TYPE tab512.

  LOOP AT lt_input INTO ls_input FROM lv_tabix.

    IF ls_input IS NOT INITIAL.
      ls_sub_input = ls_input.
      APPEND ls_sub_input TO lt_sub_input.
    ELSE.
      lv_tabix = sy-tabix.
      RETURN.
    ENDIF.

  ENDLOOP.


ENDFORM.

FORM group_processing  TABLES lt_input STRUCTURE tab512
  lt_output STRUCTURE tab512.

  DATA: ls_output  TYPE tab512,
        ls_group   TYPE gty_group,
        lt_group_i TYPE TABLE OF gty_group,
        lt_group_d TYPE TABLE OF gty_group,
        lt_group_u TYPE TABLE OF gty_group,
        lv_msg     TYPE string,
        lv_status  TYPE c,
        lv_gcount  TYPE i,
        lv_cx_all  TYPE REF TO cx_root,
        lv_thismsg TYPE string,
        lv_index   TYPE string,
        lv_action  TYPE string,
        ls_input   TYPE tab512,       "+V001
        lv_lines   TYPE i,            "+V001
        lt_tsrvgrp_d TYPE STANDARD TABLE OF tsrvgrp,
        ls_tsrvgrp   TYPE tsrvgrp,
        lt_tsrvlst_d TYPE STANDARD TABLE OF tsrvlst,
        ls_tsrvlst   TYPE tsrvlst.

  ls_output = gc_group.  " Subheading for group
  APPEND ls_output TO lt_output.
  CLEAR ls_output.

  DESCRIBE TABLE lt_input LINES lv_lines.
  IF lv_lines > 1. " To check if the imported file has data
*  Form to replace Null value (From PYTHON) of fields with blank
    PERFORM blank_check TABLES lt_input.
    DELETE lt_input INDEX 1." To delete the header line and data head
  ELSE. " If no data inputed from PYTHON
    ls_output  = gc_nodata.
    APPEND ls_output TO lt_output.
    CLEAR ls_output.
    RETURN.
  ENDIF.
  CLEAR: lv_gcount, lv_lines.

  LOOP AT lt_input INTO ls_input.
    SPLIT ls_input AT gc_sep INTO
          lv_index
          ls_group-group
          lv_action.

    CASE lv_action.
      WHEN gc_delete.
        APPEND ls_group TO lt_group_d. " Groups to be deleted
      WHEN gc_update.
        APPEND ls_group TO lt_group_u. " Groups to be updated
      WHEN gc_insert.
        APPEND ls_group TO lt_group_i. " Groups to be inserted
    ENDCASE.
    CLEAR: ls_group, lv_action, ls_input, lv_index.
  ENDLOOP.
**********************DELETE Group entries*****************
* Group delete from the list with all the instances present in group
  IF lt_group_d IS NOT INITIAL."check input has groups to be deleted
* As per the input groups to be deleted table TSRVGRP table is checked
*  to ensure the groups exist in system.
    SELECT * FROM tsrvgrp
    INTO TABLE lt_tsrvgrp_d
          FOR ALL ENTRIES IN lt_group_d
          WHERE grpname = lt_group_d-group.
    IF sy-subrc EQ 0. " Group exist check
* As per the input groups to be deleted the instances linked to it
*are fetched from TSRVLST table as all instances should also be deleted
      SELECT * FROM tsrvlst
      INTO TABLE lt_tsrvlst_d
            FOR ALL ENTRIES IN lt_tsrvgrp_d
            WHERE guid = lt_tsrvgrp_d-guid.
      DESCRIBE TABLE lt_tsrvgrp_d LINES lv_lines. "Groups to be deleted
      LOOP AT lt_tsrvgrp_d INTO ls_tsrvgrp.
        READ TABLE lt_tsrvlst_d INTO ls_tsrvlst
        WITH KEY guid = ls_tsrvgrp-guid.
        IF sy-subrc EQ 0.
*Enqueue the selected group.
          TRY.
              CALL FUNCTION 'ENQUEUE_ESTSRVGRP'
                EXPORTING
                  guid           = ls_tsrvgrp-guid
                EXCEPTIONS
                  foreign_lock   = 1
                  system_failure = 2
                  OTHERS         = 3.
              IF sy-subrc <> 0.
                CONCATENATE gc_tsrvlst gc_enqueue INTO ls_output
                SEPARATED BY space. "Msg to denote lock of table failed
                APPEND ls_output TO lt_output.
                CLEAR: ls_output, lv_lines.
                RETURN.
              ENDIF.
* Method to delete group ith has servers in it.
              CALL METHOD cl_bp_group_factory=>delete_group_by_name
                EXPORTING
                  i_name      = ls_tsrvgrp-grpname
                  i_force_del = cl_bp_const=>true
                  do_commit   = cl_bp_const=>true.

            CATCH cx_bp_health_data INTO lv_cx_all.
              lv_thismsg = lv_cx_all->get_text( ).
              CONCATENATE gc_grperror ls_tsrvgrp-grpname INTO ls_output
              SEPARATED BY space. "Msg: Group not deleted
              APPEND ls_output TO lt_output.
              CLEAR ls_output.
              "Count reduced if group not deleted
              lv_lines = lv_lines - 1.
          ENDTRY.
* Dequeue the selected group.
          CALL FUNCTION 'DEQUEUE_ESTSRVGRP'
            EXPORTING
              guid = ls_tsrvgrp-guid.
          IF sy-subrc <> 0.
            CONCATENATE gc_tsrvlst gc_dequeue INTO ls_output
            SEPARATED BY space." Msg to denote unlock of table failed
            APPEND ls_output TO lt_output.
            CLEAR ls_output.
          ENDIF.
        ELSE.
*Enqueue the selected group.
          TRY.
              CALL FUNCTION 'ENQUEUE_ESTSRVGRP'
                EXPORTING
                  guid           = ls_tsrvgrp-guid
                EXCEPTIONS
                  foreign_lock   = 1
                  system_failure = 2
                  OTHERS         = 3.
              IF sy-subrc <> 0.
                CONCATENATE gc_tsrvlst gc_enqueue INTO ls_output
                SEPARATED BY space." Msg to denote lock of table failed
                APPEND ls_output TO lt_output.
                CLEAR: ls_output, lv_lines.
                RETURN.
              ENDIF.
* Method to delete empty group
              CALL METHOD cl_bp_group_factory=>delete_group_by_name
                EXPORTING
                  i_name    = ls_tsrvgrp-grpname
                  do_commit = cl_bp_const=>true.

            CATCH cx_bp_health_data INTO lv_cx_all.
              lv_thismsg = lv_cx_all->get_text( ).
              CONCATENATE gc_grperror ls_tsrvgrp-grpname INTO ls_output
              SEPARATED BY space. "Msg: Group not deleted
              APPEND ls_output TO lt_output.
              CLEAR ls_output.
              "Count reduced if group not deleted
              lv_lines = lv_lines - 1.
          ENDTRY.
* Dequeue the selected group.
          CALL FUNCTION 'DEQUEUE_ESTSRVGRP'
            EXPORTING
              guid = ls_tsrvgrp-guid.
          IF sy-subrc <> 0.
            CONCATENATE gc_tsrvlst gc_dequeue INTO ls_output
            SEPARATED BY space. "Msg to denote unlock of table failed
            APPEND ls_output TO lt_output.
            CLEAR ls_output.
          ENDIF.
        ENDIF.
        CLEAR: ls_tsrvgrp, ls_tsrvlst.
      ENDLOOP.
    ENDIF.
  ENDIF.
*  Count of the groups deleted.
  gv_count = lv_lines.
  CONCATENATE gc_dmsg ':' gv_count INTO ls_output
  SEPARATED BY space.  "No of group deleted
  APPEND ls_output TO lt_output.
  CLEAR: ls_output, lv_lines, gv_count.

**********************Insert Group entries*****************
* Group Insert from the input list
  IF lt_group_i IS NOT INITIAL.
    CLEAR: ls_group, lv_gcount,lv_msg, lv_status.
    LOOP AT lt_group_i INTO ls_group.
*  Form to create the groups and and to get the message in case there
*  is any error in creating groups.
      PERFORM grp_create_new CHANGING ls_group-group
        lv_status" S if group is created
        " or already present.
        lv_msg
        lv_gcount. "Groups created count
      IF lv_status EQ 'E'.
        ls_group-status = lv_status.
        ls_group-msg = lv_msg.
        MODIFY lt_group_i FROM ls_group. " Error in creating groups
      ELSEIF lv_status EQ 'S'.
*   Remove the entry when groups are successfully created
        DELETE TABLE lt_group_i FROM ls_group.
      ENDIF.
      CLEAR: lv_msg, lv_status, ls_group.
    ENDLOOP.
  ENDIF.
*  Count of the groups created.
  gv_count = lv_gcount.
  CONCATENATE gc_imsg ':' gv_count INTO ls_output
  SEPARATED BY space.  "No of group inserted
  APPEND ls_output TO lt_output.
  CLEAR: ls_output, gv_count, lv_gcount.

**********************Update Group entries*****************
* Group update from the input list
* This includes the groups which are present both in source and target.
* Thus no action to be done for them
  IF lt_group_u IS NOT INITIAL.
    CLEAR: lv_lines, ls_output, gv_count.
    DESCRIBE TABLE lt_group_u LINES lv_lines.
    gv_count = lv_lines.
    CONCATENATE gc_umsg ':' gv_count INTO ls_output
    SEPARATED BY space.  "No of group same in source and target
    APPEND ls_output TO lt_output.
    CLEAR: ls_output, gv_count, lv_lines.
  ENDIF.

* Logic for giving output of groups which are not sucessfdully created
* due to error.
  IF lt_group_i IS NOT INITIAL.
    CLEAR: ls_group, ls_output.
    APPEND ls_output TO lt_output. " To give a blank line
    ls_output =  gc_subhead.  " Error heading
    APPEND ls_output TO lt_output.
    CLEAR ls_output.
    CONCATENATE gc_group gc_sep
    gc_message INTO ls_output. " Table haeding for error
    APPEND ls_output TO lt_output.
    CLEAR ls_output.
    LOOP AT lt_group_i INTO ls_group.
      CONCATENATE ls_group-group gc_sep " Error creating group data
      ls_group-msg  INTO ls_output.
      APPEND ls_output TO lt_output.
      CLEAR: ls_group, ls_output.
    ENDLOOP.
  ENDIF.

  CLEAR: ls_output, ls_group, lv_status, lv_msg, lv_lines,
  gv_count, lv_index.
  FREE: lt_group_i, lt_group_u, lt_group_d, lt_tsrvlst_d.
ENDFORM.
FORM blank_check TABLES lt_table TYPE table.

  DO .
    REPLACE ALL OCCURRENCES OF SUBSTRING '|NULL|'
    IN TABLE lt_table WITH '||'.
    FIND '|NULL|' IN TABLE lt_table.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.
  ENDDO.
  DO .

    REPLACE ALL OCCURRENCES OF SUBSTRING '|NULL'
    IN TABLE lt_table WITH '|'.
    FIND '|NULL' IN TABLE lt_table.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.
  ENDDO.

ENDFORM.

FORM grp_create_new  CHANGING i_new_grp TYPE bpsrvgrp
  lv_status TYPE c
  lv_msg    TYPE string
  lv_gcount TYPE i.

  CONSTANTS: empty_server_group TYPE bpsrvgrp VALUE '$<}'.
  DATA:
    p_groups        TYPE bpgrpentry,
    p_name_length   TYPE i,
    p_field_length  TYPE i,
    p_grp_obj       TYPE REF TO cl_bp_server_group,
    p_int_as_string TYPE char20.

  DATA: BEGIN OF p_text.
  DATA:
    part1 TYPE char40,
    part2 TYPE char40,
    END OF p_text.

  CLEAR: p_name_length, p_field_length, p_int_as_string, p_text,
  lv_gcount.

  CONDENSE i_new_grp NO-GAPS.

  IF i_new_grp = empty_server_group.
    lv_msg = 'Invalid server group name'.
    lv_status = 'E'.
  ENDIF.

  p_name_length = strlen( i_new_grp ) + 2.
  DESCRIBE FIELD i_new_grp LENGTH p_field_length IN CHARACTER MODE.
  IF p_name_length > p_field_length.
    p_int_as_string = p_name_length - p_field_length.
    CONDENSE p_int_as_string.
    p_text = 'The given name is & Symbol(s) longer as allowed'.
    REPLACE '&' IN p_text WITH p_int_as_string.
    lv_msg = p_text.
    lv_status = 'E'.
    RETURN.
  ENDIF.

  TRY.
*   Method to get Groups present in SM61
      CALL METHOD cl_bp_group_factory=>get_group_names
        IMPORTING
          o_grouplist = p_groups.
      READ TABLE p_groups
      TRANSPORTING NO FIELDS WITH KEY grpname = i_new_grp.
      IF sy-subrc = 0. " If group is already present
        lv_status = 'S'.
        lv_msg = 'Group already present'.
        RETURN.
      ENDIF.
*  Method to create the new group
      CALL METHOD cl_bp_group_factory=>make_group_by_name
        EXPORTING
          i_name         = i_new_grp
        RECEIVING
          o_grp_instance = p_grp_obj.

    CATCH cx_bp_database cx_bp_health_data.
      " Dequeue namespace.
      CALL FUNCTION 'DEQUEUE_ESTSRVGRP'.
      lv_msg = 'Delete from table BTCCTL failed'.
      lv_status = 'S'.
  ENDTRY.
  TRY.
*   Method to save changes in DB
      CALL METHOD p_grp_obj->save_db
        EXPORTING
          do_commit = 'X'.
      IF sy-subrc EQ 0.
        lv_msg = 'Group Created'.
        lv_status = 'S'.
        lv_gcount = lv_gcount + 1.
      ENDIF.

    CATCH cx_bp_database.
      " Dequeue namespace.
      CALL FUNCTION 'DEQUEUE_ESTSRVGRP'.
      lv_msg = 'Delete from table BTCCTL failed'.
      lv_status = 'S'.
  ENDTRY.

ENDFORM.
FORM server_processing  TABLES lt_input STRUCTURE tab512
  lt_output STRUCTURE tab512.

  DATA: ls_output    TYPE tab512,
        ls_server    TYPE gty_server,
        lt_tsrvlst_i TYPE TABLE OF tsrvlst,
        lt_server_d  TYPE TABLE OF gty_server,
        lt_server_i  TYPE TABLE OF gty_server,
        lt_server_u  TYPE TABLE OF gty_server,
*  Begin of changes V001
        lt_tsrvlst_d TYPE TABLE OF tsrvlst,
        ls_input     TYPE tab512,
        lv_srhost    TYPE string,
        lv_srstate   TYPE string,
        lv_srwp      TYPE string,
        lv_srbtcwp   TYPE string,
        lv_srbtcwpca TYPE string,
        lv_action    TYPE string,
        lt_tsrvgrp   TYPE STANDARD TABLE OF tsrvgrp,
        ls_tsrvgrp   TYPE tsrvgrp,
        lt_tsrvlst   TYPE STANDARD TABLE OF tsrvlst,
        ls_tsrvlst   TYPE tsrvlst,
        lv_lines     TYPE i.
*  End of changes V001

  ls_output = gc_server.  " Subheading for Server
  APPEND ls_output TO lt_output.
  CLEAR ls_output.

  DESCRIBE TABLE lt_input LINES lv_lines.
  IF lv_lines > 1. " To check if the imported file has data
*  Form to replace Null value (From PYTHON) of fields with blank
    PERFORM blank_check TABLES lt_input.
    DELETE lt_input INDEX 1." To delete the header line and data head
  ELSE. " If no data inputed from PYTHON
    ls_output  = gc_nodata.
    APPEND ls_output TO lt_output.
    CLEAR ls_output.
    RETURN.
  ENDIF.
  LOOP AT lt_input INTO ls_input.
    SPLIT ls_input AT gc_sep INTO
    ls_server-group
    ls_server-instance
    lv_srhost
    lv_srstate
    lv_srwp
    lv_srbtcwp
    lv_srbtcwpca
    lv_action.

    CASE lv_action.
      WHEN gc_delete.
        APPEND ls_server TO lt_server_d. " Groups to be deleted
      WHEN gc_update.
        APPEND ls_server TO lt_server_u. " Groups to be updated
      WHEN gc_insert.
        APPEND ls_server TO lt_server_i. " Groups to be inserted
    ENDCASE.
    CLEAR: ls_server, lv_action, ls_input,lv_srhost, lv_srstate,
    lv_srwp, lv_srbtcwp, lv_srbtcwpca  .
  ENDLOOP.

* All the groups are fetched to check the corresponding instances
  SELECT * FROM tsrvgrp
  INTO TABLE lt_tsrvgrp.

* FM to enqueue the TSRVLST table
  CALL FUNCTION 'ENQUEUE_E_TABLE'
    EXPORTING
      mode_rstable   = gc_mode
      tabname        = gc_tsrvlst
    EXCEPTIONS
      foreign_lock   = 1
      system_failure = 2
      OTHERS         = 3.
  IF sy-subrc <> 0.
    CONCATENATE gc_tsrvlst gc_enqueue INTO ls_output
     SEPARATED BY space. " Msg to denote lock of table failed
    APPEND ls_output TO lt_output.
    CLEAR ls_output.
    RETURN.
  ENDIF.
**********************DELETE Server entries*****************
* Server delete from the list with all the instances present in group
  IF lt_server_d IS NOT INITIAL.

* As per the input groups to be deleted the instances linked to it
*are fetched from TSRVLST table as all instances should also be deleted
    SELECT * FROM tsrvlst
    INTO TABLE lt_tsrvlst
          FOR ALL ENTRIES IN lt_tsrvgrp
          WHERE guid = lt_tsrvgrp-guid.
    CLEAR: ls_server.
    LOOP AT lt_server_d INTO ls_server.
*   Check if the input group is present in Group table(TSRVGRP)
      READ TABLE lt_tsrvgrp INTO ls_tsrvgrp WITH KEY
            grpname = ls_server-group.
      IF sy-subrc EQ 0.
*   Check if the input server is present in server table(TSRVLST).
*   Additionally check if server is linked to the group as input.
        READ TABLE lt_tsrvlst INTO ls_tsrvlst WITH KEY
              guid = ls_tsrvgrp-guid
              appsrvname = ls_server-instance.
        IF sy-subrc EQ 0.
          APPEND ls_tsrvlst TO lt_tsrvlst_d.
        ENDIF.
      ENDIF.
      CLEAR: ls_server, ls_tsrvgrp, ls_tsrvlst.
    ENDLOOP.
*   Final internal table with servers to be deleted.
    IF lt_tsrvlst_d IS NOT INITIAL.
      DELETE tsrvlst FROM TABLE lt_tsrvlst_d. " Delete Server
      COMMIT WORK.
    ENDIF.
  ENDIF.
* Deleted Instance count
  CLEAR: lv_lines, ls_output, gv_count.
  DESCRIBE TABLE lt_server_d LINES lv_lines.
  gv_count = lv_lines.
  CONCATENATE gc_dmsg ':' gv_count INTO ls_output
  SEPARATED BY space.  "No of instance deleted
  APPEND ls_output TO lt_output.
  CLEAR: ls_output, lv_lines,gv_count.


**********************Insert Server entries*****************
* Server insert from the list with all the instances present in group
  IF lt_server_i IS NOT INITIAL.
    CLEAR: ls_output, ls_tsrvgrp, lv_lines, gv_count, ls_server.
    LOOP AT lt_server_i INTO ls_server.
*  Check if group is present in Group table TSRGRP
      READ TABLE lt_tsrvgrp INTO ls_tsrvgrp WITH KEY
      grpname = ls_server-group.
      IF sy-subrc EQ 0. " Group is present
        ls_tsrvlst-guid = ls_tsrvgrp-guid.
        ls_tsrvlst-appsrvname = ls_server-instance.
        ls_tsrvlst-moddate   = sy-datum.
        APPEND ls_tsrvlst TO lt_tsrvlst_i.
      ENDIF.
      CLEAR: ls_tsrvlst, ls_server, ls_tsrvgrp.
    ENDLOOP.
*  Logic to insert new servers if the internal table has data
    IF lt_tsrvlst_i IS NOT INITIAL.
      MODIFY tsrvlst FROM TABLE lt_tsrvlst_i. " Insert Server
      COMMIT WORK.
    ENDIF.
  ENDIF.
  DESCRIBE TABLE lt_tsrvlst_i LINES lv_lines."Servers inserted
  gv_count = lv_lines.
  CONCATENATE gc_imsg ':' gv_count INTO ls_output
  SEPARATED BY space.  "No of instance inserted
  APPEND ls_output TO lt_output.
  CLEAR: ls_output, lv_lines,gv_count.
**********************Update Server entries*****************
* Server update from the list with all the instances present in group
  IF lt_server_u IS NOT INITIAL.
    CLEAR: lv_lines, ls_output, gv_count.
    DESCRIBE TABLE lt_server_u LINES lv_lines.
    gv_count = lv_lines.
    CONCATENATE gc_umsg ':' gv_count INTO ls_output
    SEPARATED BY space.  "No of instance same in source and target
    APPEND ls_output TO lt_output.
    CLEAR: ls_output, lv_lines,gv_count.
  ENDIF.

* FM to enqueue the TSRVLST table
  CALL FUNCTION 'DEQUEUE_E_TABLE'
    EXPORTING
      mode_rstable = gc_mode
      tabname      = gc_tsrvlst.
  IF sy-subrc <> 0.
    CONCATENATE gc_tsrvlst gc_enqueue INTO ls_output
     SEPARATED BY space. " Msg to denote unlock of table failed
    APPEND ls_output TO lt_output.
    CLEAR ls_output.
  ENDIF.
  CLEAR: ls_server, lv_action, ls_input, ls_tsrvgrp, ls_tsrvlst,
  lv_srhost, lv_srstate,lv_srwp, lv_srbtcwp, lv_srbtcwpca.
  FREE: lt_server_d, lt_server_u, lt_server_i,lt_tsrvgrp,
  lt_tsrvlst, lt_tsrvlst_d, lt_tsrvlst_i.
ENDFORM.