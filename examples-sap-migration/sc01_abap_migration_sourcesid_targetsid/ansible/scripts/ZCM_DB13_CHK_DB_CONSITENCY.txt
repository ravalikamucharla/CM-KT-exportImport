*---------------------------------------------------------------------*
* Program Name        :   ZCM_DB13_CHK_DB_CONSITENCY                  *
* Title               :   Logical Systems                             *
* Purpose             :   This report is used check previous 24 hrs if*
*                         if any DB check job is run and do below task*
*                           -> if yes- get status and job log         *
*                           -> if no- message is sent as output       *
*---------------------------------------------------------------------*
* Related Transaction OR Standard Program References                  *
* DB13                                                                *
*---------------------------------------------------------------------*
* Tables              :   SELECT    UPDATE      INSERT      DELETE    *
* SDBAP                     X                                         *
*---------------------------------------------------------------------*
* Program Change History                                              *
*---------------------------------------------------------------------*
*Date        Version   Author       TR#/Local     Description         *
*---------------------------------------------------------------------*
*12-01-2020  Initial   Soumya Ray   Local         To check the DB     *
*                                                 consistency         *
*10-14-2022  V001      Soumya Ray   Local         To remove inline de-*
*                                                 clarations          *
*---------------------------------------------------------------------*


REPORT zcm_db13_chk_upd_db_consitency.

CONSTANTS : gc_sep       TYPE c      VALUE '|',
            gc_nojob     TYPE string VALUE
            'No job Scheduled in last 24 hours',
            gc_export    TYPE char8  VALUE 'EXPORT',
            gc_head      TYPE string VALUE 'Check DB Consistency',
            gc_status    TYPE char6  VALUE 'Status',
            gc_joblog    TYPE string VALUE 'Joblog',
            gc_ckdb_sql  TYPE char10 VALUE 'MSS',
            gc_veri_hdb  TYPE char10 VALUE 'HDB',
            gc_check_ora TYPE char10 VALUE 'ORA',
            gc_enterdate TYPE string VALUE 'Enterdate',
            gc_entertime TYPE string VALUE 'Entertime',
            gc_text      TYPE string VALUE 'Text',
            gc_msgid     TYPE string VALUE 'Messageid',
            gc_msgno     TYPE string VALUE 'Msgno',
            gc_msgtype   TYPE string VALUE 'Msgtype'.

LOAD-OF-PROGRAM.

FORM get_config
               TABLES lt_input  STRUCTURE tab512
                      lt_output STRUCTURE tab512.

* Begin of changes in V001
  CONSTANTS: lc_inc_input TYPE c VALUE 'Incorrect input'    LENGTH 20,
             lc_noinput   TYPE c VALUE 'No input given'     LENGTH 20.
* End of changes in V001

  DATA: ls_db6_logs TYPE db6pmprot,
        lo_sys      TYPE REF TO cl_db6_sys,
        lo_exec     TYPE REF TO cx_db6_sys,
        lv_btype    TYPE sdba_btype,
        ls_output   TYPE tab512,
        lv_job_flg  TYPE char1,
* Begin of changes in V001
        lv_action   TYPE string,
        ls_input    TYPE tab512,
        lv_datum    TYPE sy-datum,
        lv_time     TYPE sy-uzeit,
        lv_sysid    TYPE sy-sysid,
        lv_dbname   TYPE DBCON_DBMS.
* End of changes in V001

  CLEAR: lv_job_flg, ls_output, lv_btype,
         lv_action, ls_input, lv_datum, lv_time, lv_sysid,
         lv_dbname. "+V001

  ls_output = gc_head.  " Title of script
  APPEND ls_output TO lt_output.
  CLEAR ls_output.

  READ TABLE lt_input INTO ls_input INDEX 1.
* Begin of changes in V001
  IF sy-subrc NE 0.
    " No input given
    ls_output = lc_noinput.
    APPEND ls_output TO lt_output.
    CLEAR ls_output.
    RETURN.
  ENDIF.
* End of changes in V001
  lv_action = ls_input.

  lv_datum = sy-datum.
  lv_time  = sy-uzeit.
  lv_sysid = sy-sysid.

  CASE lv_action.
    WHEN gc_export.

*  Logic to get the system reference based on the system id
      TRY .
          cl_db6_sys=>get_sys_ref(
          EXPORTING
            system_id     = lv_sysid
            RECEIVING
            sys_ref       = lo_sys        ).

        CATCH cx_db6_sys INTO lo_exec.

      ENDTRY.

      IF lo_sys IS BOUND. " If the database reference is bound
* logic to get the database name

        IF lo_sys->con_ref IS NOT INITIAL.
          lv_dbname = lo_sys->con_ref->con_data-dbms.
        ELSE.
*        Check for current s/m being SQL
          IF lo_sys->sys_data IS NOT INITIAL.
            lv_dbname = lo_sys->sys_data-dbsys.
          ENDIF.
        ENDIF.
        CASE lv_dbname.
          WHEN gc_ckdb_sql.
            lv_btype = 'CKDB'.
          WHEN gc_veri_hdb.
            lv_btype = 'VERI'.
          WHEN gc_check_ora.
            lv_btype = 'CHECK'.
        ENDCASE.

*   To read the status and log of the check consistency job if
*   submitted in the time range
        PERFORM status_read TABLES lt_output
        USING    lo_sys
                 lv_datum
                 lv_time
                 lv_sysid
                 lv_btype
                 lv_dbname
        CHANGING ls_db6_logs
                 lv_job_flg
                 ls_output .

*  The flag is checked to ensure check database consistency job id not
*  run in last 24 hrs.
        IF lv_job_flg EQ 'X'.
          RETURN.
        ELSE.
          ls_output = gc_nojob.
          APPEND ls_output TO lt_output.
          CLEAR ls_output.
        ENDIF.
      ENDIF.

* Begin of changes in V001
    WHEN OTHERS.
      " Incorrect input
      ls_output = lc_inc_input.
      APPEND ls_output TO lt_output.
      CLEAR ls_output.
* End of changes in V001

  ENDCASE.
ENDFORM.
*//Form to read status of the latest check consistency job run the
*//time limit specified
FORM status_read  TABLES   lt_output TYPE table
                  USING    lo_sys TYPE REF TO cl_db6_sys
                           lv_datum TYPE sy-datum
                           lv_time    TYPE sy-uzeit
                           lv_sysid   TYPE sy-sysid
                           lv_btype   TYPE sdba_btype
                           lv_dbname    TYPE db6navsyst-dbsys
                  CHANGING ls_db6_logs TYPE db6pmprot
                           lv_job_flg  TYPE c
                           ls_output   TYPE tab512.

  DATA: lt_db6_logs           TYPE TABLE OF db6pmprot,
        lt_proglog            TYPE db6_editor_list,
        lv_seconds            TYPE i,
        lv_start              TYPE db6tstamp_struct,
        lv_endtime            TYPE db6tstamp_struct,
        lv_running            TYPE db6tstamp_struct,
        lv_current_dba_config TYPE REF TO cl_dba_config,
        ls_recurrence         TYPE sdba_recur,
        lv_msg                TYPE string,
        lv_status             TYPE i,
        lv_predate            TYPE sy-datum,
        lt_batchlog           TYPE db6jo_batchlog_table,
        lv_function_name      TYPE syrepid,
* Begin of changes in V001
        ls_proglog            TYPE db6_editor_line,
        lv_cretstmpre         TYPE DB6TSTAMP,
        lt_sdbap              TYPE STANDARD TABLE OF sdbap.

  FIELD-SYMBOLS: <fs_log>     TYPE tbtc5.
  FREE: lt_sdbap.
* End of changes in V001

* Under the pre-migration activities, the data
* related to DBA planning created in the system exported to Python
* The table SDBAP holds this data. This is read to
* determine the number of DBA planning actions in the system
  lv_predate = lv_datum - 1. " To get the previous date
  CONCATENATE lv_predate
              lv_time INTO lv_cretstmpre." Previous timestamp
  lv_start-date = lv_datum.
  lv_start-time = lv_time.
* Select the entries in SDBAP table for the DBA action
* (check consistency)
  SELECT *
  FROM sdbap
  INTO TABLE lt_sdbap
  WHERE btype = lv_btype.
  IF sy-subrc EQ 0.
    SORT: lt_sdbap BY daye timee ASCENDING.
  ENDIF.
*    function_name = <DB name>'_LOG_READ'.
  CONCATENATE lv_dbname '_LOG_READ'
  INTO lv_function_name.

  CALL FUNCTION lv_function_name
    DESTINATION lo_sys->sys_data-rfcdest
    EXPORTING
      connection = lo_sys->sys_data-dbcname
      from_date  = lv_predate
      from_time  = lv_time
      to_date    = lv_datum
      to_time    = lv_time
      system_id  = lv_sysid
    TABLES
      logs       = lt_db6_logs
      plannings  = lt_sdbap.

* The functionality is designed to get the status of the check
* consistency job run in past between the time passed
  IF lt_db6_logs IS NOT INITIAL.
    SORT lt_db6_logs BY starttime DESCENDING.
    READ TABLE lt_db6_logs INTO ls_db6_logs WITH KEY
    progid = lv_btype.
    IF sy-subrc = 0 AND ls_db6_logs-starttime GE lv_cretstmpre .
      lv_job_flg = 'X'.
      CASE  ls_db6_logs-returncode.
        WHEN 0.
          lv_status = cl_db6_calendar_action=>act_finished.
          lv_msg =
          cl_dba_image=>image_of_action_status( lv_status ).
        WHEN 1.
          lv_status = cl_db6_calendar_action=>act_warning.
          lv_msg =
          cl_dba_image=>image_of_action_status( lv_status ).
        WHEN cl_db6_rc=>x_undefined.
          IF  ls_db6_logs-endtime IS INITIAL.
            lv_current_dba_config =
            cl_dba_config=>get_ref( sysid = lv_sysid
            dbsys = lv_dbname  ).
            lv_seconds =
            lv_current_dba_config->get_batch_overdue_time( ).
            lv_running = cl_db6_calendar_tool=>add_seconds_to_timestamp(
             seconds   = lv_seconds
             timestamp = lv_start ).
          ELSE.
            lv_running = cl_db6_calendar_tool=>add_hours_to_timestamp(
            hours     = 12
            timestamp = lv_endtime ).
          ENDIF.
          IF lv_running-date > sy-datum OR
          ( lv_running-date = sy-datum AND
          lv_running-time > sy-uzeit     ).
            lv_status = cl_db6_calendar_action=>act_running.
            lv_msg = cl_dba_image=>image_of_action_status( lv_status ).
          ELSE.
            lv_status = cl_db6_calendar_action=>act_error.
            lv_msg = cl_dba_image=>image_of_action_status( lv_status ).
          ENDIF.
        WHEN OTHERS.
          lv_status = cl_db6_calendar_action=>act_error.
          lv_msg = cl_dba_image=>image_of_action_status( lv_status ).
      ENDCASE.
    ENDIF.
  ENDIF.
*  Status export for check consistency job selected
  IF lv_msg NE ''.
    ls_output = gc_status. " Status head
    APPEND ls_output TO lt_output.
    CLEAR ls_output.
    ls_output = lv_msg. " Status data
    APPEND ls_output TO lt_output.
    CLEAR ls_output.
    APPEND ls_output TO lt_output.
  ENDIF.

* // Start of logic to get Job log depending upon the db.
  CASE lv_dbname.
    WHEN gc_ckdb_sql. "MSSQL DB
      IF ls_db6_logs NE space.
        CLEAR lv_function_name.
        CONCATENATE lo_sys->sys_data-dbsys
        '_JOB_GET_PROGRAM_LOG' INTO lv_function_name.
*  FM to get previous job log in MSSQL system
        CALL FUNCTION lv_function_name
          EXPORTING
            log           = ls_db6_logs
            recurrence    = ls_recurrence
            system        = lo_sys
          TABLES
            proglog       = lt_proglog
          EXCEPTIONS
            error_occured = cl_db6_rc=>x_error_occured
            OTHERS        = cl_db6_rc=>x_others.
        IF lt_proglog IS NOT INITIAL.
          ls_output = gc_joblog.
          APPEND ls_output TO lt_output.
          CLEAR ls_output.
          LOOP AT lt_proglog INTO ls_proglog.
            ls_output = ls_proglog.
            APPEND ls_output TO lt_output.
            CLEAR ls_output.
          ENDLOOP.
        ENDIF.
      ENDIF.
    WHEN gc_veri_hdb. " HANA DB
      PERFORM action_buffer TABLES lt_sdbap
                                   lt_batchlog
                            USING  ls_db6_logs
                                   lv_dbname
                                   lo_sys
                                   lv_btype.
    WHEN gc_check_ora. "Oracle DB
      PERFORM action_buffer TABLES lt_sdbap
                                   lt_batchlog
                            USING  ls_db6_logs
                                   lv_dbname
                                   lo_sys
                                   lv_btype.
  ENDCASE.
  IF NOT lt_batchlog IS INITIAL.

    ls_output = gc_joblog.
    APPEND ls_output TO lt_output.
    CLEAR: ls_output.

    CONCATENATE gc_enterdate gc_sep
                gc_entertime gc_sep
                gc_text gc_sep
                gc_msgid gc_sep
                gc_msgno gc_sep
                gc_msgtype INTO ls_output. "Sub heading for the job log
    APPEND ls_output TO lt_output.
    CLEAR: ls_output.

    LOOP AT lt_batchlog ASSIGNING <fs_log>.
      CONCATENATE <fs_log>-enterdate gc_sep
      <fs_log>-entertime gc_sep
      <fs_log>-TEXT gc_sep
      <fs_log>-msgid gc_sep
      <fs_log>-msgno gc_sep
      <fs_log>-msgtype INTO ls_output." Job log data
      APPEND ls_output TO lt_output.
    ENDLOOP.
    PERFORM null_check TABLES  lt_output.
  ENDIF.

* // End of logic to get Job log depending upon the db.

ENDFORM.
*// Form to get the action buffer of check consistency job
*// The status and log of the job are fetched from here
FORM action_buffer  TABLES   lt_sdbap    STRUCTURE sdbap
                             lt_batchlog TYPE db6jo_batchlog_table
                    USING    ls_db6_logs TYPE  db6pmprot
                             lv_dbname   TYPE db6navsyst-dbsys
                             lo_sys      TYPE REF TO cl_db6_sys
                             lv_btype    TYPE sdba_btype.

  DATA: ls_planning_entry    TYPE db6jo_planning_entry,
        lt_planning_buffer   TYPE STANDARD TABLE OF
        db6jo_planning_entry,
        lv_first_planning    TYPE db6tstamp_struct,
        lv_period_in_seconds TYPE i,
        ls_from              TYPE db6tstamp_struct,
        ls_to                TYPE db6tstamp_struct,
        lv_from_date         TYPE sydatum,
        ls_recurrence        TYPE sdba_recur,
        ls_data              TYPE sdbap,
        lv_delta             TYPE p,
        lv_period            TYPE i,
        ls_plan              TYPE sdbap,
        lv_sys_id            TYPE db6navsyst-sysid,
        lt_db6_logs          TYPE TABLE OF db6pmprot,
        lv_current_planning  TYPE db6tstamp_struct,
        lt_expanded_planning TYPE TABLE OF sdbap,
        ls_action_entry      TYPE db6jo_action,
        lv_logname           TYPE db6path,
        ls_log_entry         TYPE db6jo_log_entry,
        lt_logs              TYPE db6jo_log_entry_table,
        lt_action_buffer     TYPE db6jo_action_table,
        lv_function_name     TYPE syrepid,
        lv_planning_index    TYPE sytabix,
        ls_from_oracle       TYPE db6tstamp_struct,
        lv_timestamp         TYPE db6tstamp_struct,
        lo_calenderdb        TYPE REF TO cl_db6_calendar_action,
        lo_calender_tool     TYPE REF TO cl_db6_calendar_tool,
*  Begin of changes in V001
        lv_to_date           TYPE sydatum,
        ls_sdbap             TYPE sdbap.
*  End of changes in V001

  FIELD-SYMBOLS: <log>  TYPE db6pmprot.

  CLEAR: ls_planning_entry.
  lv_from_date = ls_db6_logs-starttime+0(8).
  lv_to_date = lv_from_date.
  lv_period = 1.
  lv_sys_id = sy-sysid.
* Create onjects
  CREATE OBJECT lo_calenderdb.
  CREATE OBJECT lo_calender_tool.
* Logic to compose the planning buffer from SDBAP table entries
  LOOP AT lt_sdbap INTO ls_sdbap.
    ls_planning_entry-data = ls_sdbap.
    APPEND ls_planning_entry TO lt_planning_buffer.
    CLEAR: ls_sdbap, ls_planning_entry.
  ENDLOOP.

*//Start of logic to compose the action buffer from SDBAP table entries
  LOOP AT lt_planning_buffer INTO ls_planning_entry.
    ls_action_entry-plan_ref = sy-tabix.
    ls_action_entry-sysid = sy-sysid.
    lv_first_planning =
    lo_calenderdb->first_start( ls_planning_entry-data ).
    lv_period_in_seconds =
    lo_calenderdb->action_period( ls_planning_entry-data ).
    DO 24 TIMES.
      ls_from-time = ( sy-index - 1 ) * 3600.
      ls_to-time   = ls_from-time + 3599.
      ls_from-date = lv_from_date.
      DO lv_period TIMES.
        ls_to-date = ls_from-date.
        lv_current_planning = lv_first_planning.
        IF ls_planning_entry-data-period <> 0      AND
              lv_current_planning  <  ls_from.
          lv_delta =
          lo_calender_tool->time_diff_struct( start =
          lv_current_planning
          endt = ls_to ) .
          lv_delta =
          lv_delta DIV lv_period_in_seconds * lv_period_in_seconds.
          lv_current_planning =
         lo_calender_tool->add_seconds_to_timestamp( seconds = lv_delta
          timestamp =  lv_current_planning ).
        ENDIF.
        IF lv_current_planning BETWEEN ls_from AND ls_to       AND
        ( ls_planning_entry-data-deltstmp >
              lv_current_planning OR
        ls_planning_entry-data-deltstmp IS INITIAL ).
          ls_action_entry-day =
          lo_calender_tool->daynumber_of_date(
          lv_current_planning-date ).
          ls_action_entry-date = lv_current_planning-date.
          ls_action_entry-time = lv_current_planning-time.
          APPEND ls_action_entry TO lt_action_buffer.

          ls_plan = ls_planning_entry-data.
          ls_plan-starttstmp = lv_current_planning.
          IF ls_plan-sysid <> '*'.
            APPEND ls_plan TO lt_expanded_planning.
          ENDIF.
        ENDIF.
        ls_from-date = ls_from-date + 1.
      ENDDO.
    ENDDO.
    CLEAR: ls_planning_entry, ls_action_entry,
    ls_from,ls_to, lv_current_planning, lv_delta,
    ls_plan .
*// End of logic for action buffer
    SORT lt_action_buffer DESCENDING BY date day time.
    ls_to-date = lv_from_date + lv_period - 1.
* Database logs got as per the extended planning entries
    CONCATENATE lv_dbname '_LOG_READ'
    INTO lv_function_name.
    CALL FUNCTION lv_function_name
      DESTINATION lo_sys->sys_data-rfcdest
      EXPORTING
        connection = lo_sys->sys_data-dbcname
        from_date  = lv_from_date
        from_time  = '000000'
        to_date    = lv_to_date
        to_time    = '235959'
        system_id  = lv_sys_id
      TABLES
        logs       = lt_db6_logs
        plannings  = lt_expanded_planning.
  ENDLOOP.

* Transfer all log entries except Userexit Log
  LOOP AT lt_db6_logs ASSIGNING <log>
  WHERE progid <> db6jo_id_userexit.
    ls_log_entry-external = 'X'."Default: Assume
    ls_log_entry-log      = <log>.
    APPEND ls_log_entry TO lt_logs.
    CLEAR:ls_log_entry, <log>.
  ENDLOOP.
**
  SORT lt_logs[] BY log-progid log-starttime
  log-returncode DESCENDING.

*// start of logic to mapp logs to action buffer

  LOOP AT lt_action_buffer INTO ls_action_entry.

    lv_planning_index = sy-tabix.

    ls_from-date = ls_action_entry-date.
    ls_from-time = ls_action_entry-time.
    READ TABLE lt_planning_buffer INDEX ls_action_entry-plan_ref
    INTO ls_planning_entry.

    IF lv_dbname = 'ORA' AND
    ls_planning_entry-data-sysid <> '*' AND
    ls_planning_entry-data-btype <>
          cl_db6_calendar_cfg_meta=>co_id_nls_cleanup.
      ls_from_oracle = ls_from.
      IF lo_sys->sys_data-saprel(1) = '4'.
* start search 60 sec before, due to time differences  saprel < 46
        ls_from_oracle =
        cl_db6_calendar_tool=>sub_seconds_from_timestamp( seconds = 60
        timestamp = ls_from_oracle ).
        LOOP AT lt_logs INTO ls_log_entry
        WHERE log-starttime  >= ls_from_oracle     AND
        log-system_id   = ls_planning_entry-data-sysid  AND
              external        =  'X'.

          IF  ls_planning_entry-data-btype = ls_log_entry-log-progid
                OR
          ls_planning_entry-data-btype = 'ALGOF' AND
                ls_log_entry-log-progid = 'ALLOF' OR
          ls_planning_entry-data-btype = 'ALLOG' AND
                ls_log_entry-log-progid = 'ALL' OR
          ls_planning_entry-data-btype = 'FLGOF' AND
                ls_log_entry-log-progid = 'FLLOF' OR
          ls_planning_entry-data-btype = 'FLLOG' AND
                ls_log_entry-log-progid = 'FLL' OR
          ls_planning_entry-data-btype = 'ILGOF' AND
                ls_log_entry-log-progid = 'INCOF' OR
          ls_planning_entry-data-btype = 'INLOG' AND
                ls_log_entry-log-progid = 'INCR'.
            ls_log_entry-external = space.
            MODIFY lt_logs FROM ls_log_entry INDEX sy-tabix.
            ls_action_entry-log_ref = sy-tabix.
            MODIFY lt_action_buffer
            FROM ls_action_entry INDEX lv_planning_index.
            EXIT.
          ENDIF.
        ENDLOOP.
      ELSE.
* start search 1200 sec before, due to time differences
        ls_from_oracle =
        cl_db6_calendar_tool=>sub_seconds_from_timestamp( seconds
        = 1200
        timestamp = ls_from_oracle ).
        lv_logname = ls_planning_entry-data-btype.
        OVERLAY lv_logname WITH '___________________'.
        MOVE ls_planning_entry-data-starttstmp TO lv_logname+5.
        LOOP AT lt_logs INTO ls_log_entry
        WHERE log-commndline  = lv_logname.
          ls_log_entry-external = space.
          MODIFY lt_logs FROM ls_log_entry INDEX sy-tabix.
          ls_action_entry-log_ref = sy-tabix.
          MODIFY lt_action_buffer
          FROM ls_action_entry INDEX lv_planning_index.
          EXIT.
        ENDLOOP.
      ENDIF.
    ENDIF.

  ENDLOOP.
  "action buffer
  SORT lt_action_buffer DESCENDING BY time.

  LOOP AT lt_action_buffer INTO ls_action_entry.
    IF ls_action_entry-date EQ sy-datum AND
    ls_action_entry-time LT sy-uzeit .
      READ TABLE lt_planning_buffer INTO ls_planning_entry
      INDEX ls_action_entry-plan_ref.
      ls_data = ls_planning_entry-data.
      IF ls_data-btype = lv_btype.
        EXIT.
      ENDIF.
    ELSEIF ls_action_entry-date LT sy-datum .
      READ TABLE lt_planning_buffer INTO ls_planning_entry
      INDEX ls_action_entry-plan_ref.
      ls_data = ls_planning_entry-data.
      IF ls_data-btype = lv_btype.
        EXIT.
      ENDIF.
    ENDIF.
  ENDLOOP.
  PERFORM recurrence TABLES lt_planning_buffer
  USING ls_data
  CHANGING ls_recurrence .

  lv_timestamp-date = ls_action_entry-date.
  lv_timestamp-time = ls_action_entry-time.
* FM to get the job log for the job whose action parameter are passed
  CALL FUNCTION 'DB6_PLAN_GET_BATCHLOG'
    EXPORTING
      action                = ls_data
      recurrence            = ls_recurrence
      plan_date             = lv_timestamp-date
      plan_time             = lv_timestamp-time
      connection            = lo_sys->sys_data-dbcname
    TABLES
      messages              = lt_batchlog
    EXCEPTIONS
      no_configuration_data = cl_db6_rc=>x_no_configuration_data
      no_messages_found     = cl_db6_rc=>x_no_messages_found
      job_error             = cl_db6_rc=>x_job_error
      OTHERS                = cl_db6_rc=>x_others.
ENDFORM.
*// FM to get the recurrence period if the job scheduled in a recurring
*//job
FORM recurrence  TABLES   lt_planning_buffer TYPE db6jo_planning_table
                 USING    ls_data TYPE sdbap
                 CHANGING ls_recurrence TYPE sdba_recur.
* Code is got from method DETERMINE_RECURRENCE(CL_DB6_CALENDAR_ACTION)
  FIELD-SYMBOLS:
  <current> TYPE c.
  DATA:
    action_excp     TYPE REF TO cx_db6_calendar_action,
    lv_offset       TYPE i,
    lo_exec         TYPE REF TO cx_db6_calendar_action,
    lv_action       TYPE sdbap,
    ls_planning_entry TYPE db6jo_planning_entry. "+V001

  CLEAR ls_recurrence.
*  READ TABLE lt_planning_buffer INTO wa_planning_entry
  lv_action = ls_data.
  IF lv_action-period <> 0.
    IF lv_action-daye  = 0 AND
    lv_action-timee = '240000'.
*     hourly planning
      ls_recurrence-period = lv_action-period.
      ls_recurrence-unit   = 'H'.
    ELSEIF lv_action-daye = 0.
*     daily planning
      ls_recurrence-period = lv_action-period.
      ls_recurrence-unit = 'D'.

      LOOP AT lt_planning_buffer INTO ls_planning_entry
      WHERE data-daye     = 0 AND
      data-btype    = lv_action-btype AND
      data-cretstmp = lv_action-cretstmp AND
      data-deltstmp = lv_action-deltstmp .
        IF ls_planning_entry-data-timee(2) BETWEEN 0 AND 23.
          lv_offset = ls_planning_entry-data-timee(2).
          ASSIGN ls_recurrence-hourofday+lv_offset(1) TO <current>.
          <current> = 'X'.
        ELSE.

          TRY .

          action_excp = cl_dba_cx_factory=>create_db6_calendar_action(
          class_name  = 'CL_DB6_CALENDAR_ACTION'
          method_name = 'DETERMINE_RECURRENCE'
          action      = lv_action-btype
          rc          = cl_db6_rc=>x_invalid_planning_data ).

         CATCH cx_db6_calendar_action INTO lo_exec.

         ENDTRY.

        ENDIF.

      ENDLOOP.
      IF sy-subrc = 4.

        TRY .

        action_excp = cl_dba_cx_factory=>create_db6_calendar_action(
        class_name  = 'CL_DB6_CALENDAR_ACTION'
        method_name = 'DETERMINE_RECURRENCE'
        action      = lv_action-btype
        rc          = cl_db6_rc=>x_no_actions_found ).

        CATCH cx_db6_calendar_action INTO lo_exec.

        ENDTRY.
      ENDIF.
    ELSE.
*     weekly planning
      ls_recurrence-period = lv_action-period DIV 7.
      ls_recurrence-unit = 'W'.
*     look for all actions of this type scheduled at the same time to
*     find all days of the week
      CLEAR: ls_planning_entry.
      LOOP AT lt_planning_buffer INTO ls_planning_entry
      WHERE data-timee = lv_action-timee AND
      data-btype = lv_action-btype AND
      data-cretstmp = lv_action-cretstmp.
        IF ls_planning_entry-data-daye BETWEEN 1 AND 7.
          lv_offset = ls_planning_entry-data-daye - 1.
          ASSIGN ls_recurrence-dayofweek+lv_offset(1) TO <current>.
          <current> = 'X'.
        ELSE.
          TRY .
          action_excp = cl_dba_cx_factory=>create_db6_calendar_action(
          class_name  = 'CL_DB6_CALENDAR_ACTION'
          method_name = 'DETERMINE_RECURRENCE'
          action      = lv_action-btype
          rc          = cl_db6_rc=>x_invalid_planning_data ).

          CATCH cx_db6_calendar_action INTO lo_exec.

          ENDTRY.
        ENDIF.
      ENDLOOP.
      IF sy-subrc = 4.
        TRY .
        action_excp = cl_dba_cx_factory=>create_db6_calendar_action(
        class_name  = 'CL_DB6_CALENDAR_ACTION'
        method_name = 'DETERMINE_RECURRENCE'
        action      = lv_action-btype
        rc          = cl_db6_rc=>x_no_actions_found ).

        CATCH cx_db6_calendar_action INTO lo_exec.

        ENDTRY.
*        RAISE EXCEPTION action_excp.
      ENDIF.
    ENDIF.
  ENDIF.
  CLEAR: action_excp, lv_offset, lv_action, ls_planning_entry.
ENDFORM.
*/ Form to check the blank values in the field and replace them with
*// NULL
FORM null_check  TABLES   lt_table TYPE table.

  DO .
    REPLACE ALL OCCURRENCES OF SUBSTRING '||'
    IN TABLE lt_table WITH '|NULL|'.
    FIND '||' IN TABLE lt_table.
    IF sy-subrc <> 0.
      EXIT .
    ENDIF.
  ENDDO.

ENDFORM.