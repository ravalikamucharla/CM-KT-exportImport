*---------------------------------------------------------------------*
* Program Name        :   ZCM_ORA_MSS_CHK_DB_ENCRYPTION               *
* Title               :   DB encryption check                         *
* Purpose             :   This report is used to check if the DB      *
*                     :   is encrypted or not from tcode DBACOCKPIT   *
*                     :   pre migration                               *
*---------------------------------------------------------------------*
* Related Transaction OR Standard Program References                  *
* DBACOCKPIT                                                          *
*---------------------------------------------------------------------*
* Tables              :   SELECT    UPDATE      INSERT      DELETE    *
* XXXXX                     X                                         *
*---------------------------------------------------------------------*
* Program Change History                                              *
*---------------------------------------------------------------------*
*Date        Version   Author       TR#/Local     Description         *
*---------------------------------------------------------------------*
*09-18-2020  Initial   ASHWINI B    Local       To check DB encryption*
*09-12-2022  V001      Soumya Ray   Local       To pass message incase*
*                                               of no or wrong input  *
*---------------------------------------------------------------------*
REPORT zcm_ora_mss_chk_db_encryption.

FORM get_config
               TABLES ft_input  STRUCTURE tab512
                      ft_output STRUCTURE tab512.

  CONSTANTS: lc_sep       TYPE c      VALUE '|',
             lc_act_exp   TYPE char6  VALUE 'EXPORT',
* Begin of changes in V001
             lc_ndb       TYPE c VALUE
             'Database is not Oracle or MSS'              LENGTH 30,
             lc_msgtitle  TYPE c VALUE 'Messagetitle'     LENGTH 20,
             lc_inc_input TYPE c VALUE 'Incorrect input'  LENGTH 20,
             lc_noinput   TYPE c VALUE 'No input given'   LENGTH 20.
* End of changes in V001


  DATA: ls_input         TYPE  tab512,
        ls_output        TYPE  tab512,
        lv_action        TYPE  char8,
        lv_remote_system TYPE  dbcon_name,
        con_name         TYPE  dbcon_name,
        tablespace       TYPE  db02_sel,
        tablespace_logic TYPE  db02_sel_logic,
        size_mb          TYPE  db02_sel,
        size_mb_logic    TYPE  db02_sel_logic,
        free_mb          TYPE  db02_sel,
        free_mb_logic    TYPE  db02_sel_logic,
        block_size       TYPE  db02_sel,
        block_size_logic TYPE  db02_sel_logic,
        status           TYPE  db02_sel,
        status_logic     TYPE  db02_sel_logic,
        contents         TYPE  db02_sel,
        contents_logic   TYPE  db02_sel_logic,
        extent_man       TYPE  db02_sel,
        extent_man_logic TYPE  db02_sel_logic,
        compression      TYPE  db02_sel,
        comp_logic       TYPE  db02_sel_logic,
        lt_tab_list      TYPE STANDARD TABLE OF db02_ts_list,
        ts_output1       TYPE STANDARD TABLE OF db02_ts_list,
        lo_sys           TYPE REF TO cl_db6_sys,
        lo_exec          TYPE REF TO cx_db6_sys,
        lv_sys_id        TYPE db6navsyst-sysid,
        rem_con_ref      TYPE REF TO cl_sql_connection,
        stmt_ref         TYPE REF TO cl_sql_statement,
        lo_sql           TYPE REF TO cx_sql_exception,
        lv_sql_stmt      TYPE string,
        rs_ref           TYPE REF TO cl_sql_result_set,
        it_metadata      TYPE adbc_rs_metadata_descr_tab,
        r_metadata       TYPE REF TO  data,
        r_tabletype      TYPE REF TO  cl_abap_tabledescr,
        ex_structdescr   TYPE REF TO cl_abap_structdescr,
        ex_result_ref    TYPE REF TO data,
        lr_structdescr   TYPE REF TO cl_abap_structdescr,
        lr_structure     TYPE REF TO data,
        lv_encrypted     TYPE char2,
* Begin of changes in V001
        ls_tab_list      TYPE db02_ts_list,
        lv_msg           TYPE string,
        lv_dbname        TYPE dbcon_dbms.
* End of changes in V001

  FIELD-SYMBOLS : <ft_table>       TYPE STANDARD TABLE,
* Begin of changes in V001
                  <fs_structure>   TYPE any,
                  <fs_encrypt>     TYPE any,
                  <fs_name>        TYPE any,
                  <fs_encrypt_val> TYPE any.
*  End of changes in V001

  CLEAR: ls_input,
  lv_action.

* Begin of changes in V001
  ls_output = lc_msgtitle.
  APPEND ls_output TO ft_output.
  CLEAR ls_output.
* End of changes in V001

  " Read input values from Python
  READ TABLE ft_input INTO ls_input INDEX 1.
* Begin of changes in V001
  IF sy-subrc NE 0.
    " No input given
    ls_output = lc_noinput.
    APPEND ls_output TO ft_output.
    CLEAR ls_output.
    RETURN.
  ENDIF.
* End of changes in V001
  lv_action = ls_input.

  CASE lv_action.

    WHEN lc_act_exp. "EXPORT

* Under the pre-migration activities, it is checked
* whether the database is encrypted or not and is exported to
* Python.

***Check the database
      FREE: ft_output. "+V001
      lv_sys_id = sy-sysid. "System ID

      TRY .
          cl_db6_sys=>get_sys_ref(
          EXPORTING
            system_id     = lv_sys_id
            RECEIVING
            sys_ref       = lo_sys        ).

        CATCH cx_db6_sys INTO lo_exec.
* Begin of changes V001
          lv_msg = lo_exec->if_message~get_text( ).

          " Title
          CLEAR: ls_output.
          ls_output = 'DB check'.
          APPEND ls_output TO ft_output.

          ls_output = lv_msg.
          APPEND ls_output TO ft_output.
          CLEAR: ls_output.
          RETURN.
* End of changes V001

      ENDTRY.

***Read the database name

*check with IF lo_sys IS NOT BOUND or lo_sys->con_ref IS INITIAL.
      IF lo_sys IS BOUND.

        IF lo_sys->con_ref IS NOT INITIAL.
          lv_dbname = lo_sys->con_ref->con_data-dbms.
        ELSE.
*        Check for current s/m being SQL
          IF lo_sys->sys_data IS NOT INITIAL.
            lv_dbname = lo_sys->sys_data-dbsys.
          ENDIF.
        ENDIF.

      ELSE.

        " Title
        CLEAR: ls_output.
        ls_output = 'DB check'.
        APPEND ls_output TO ft_output.

        CLEAR: ls_output.
        ls_output = 'Connection not established'.
        APPEND ls_output TO ft_output.
        RETURN.

      ENDIF.

      IF lv_dbname IS INITIAL.
        " Title
        CLEAR: ls_output.
        ls_output = 'DB check'.
        APPEND ls_output TO ft_output.

        CLEAR: ls_output.
        ls_output = 'Connection not established'.
        APPEND ls_output TO ft_output.
        RETURN.
      ENDIF.

      CASE lv_dbname.

        WHEN 'ORA'. "ORACLE

****Below code is copied from the standard
****FM C_ORA_TS_SELECT_OPTIMIZED

          lv_remote_system = 'DEFAULT'.

          con_name = lv_remote_system.

          CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
            EXPORTING
              percentage = 0
              text       = 'selecting tablespaces...'.

          PERFORM get_ts_list    TABLES ts_output1
          USING 'ts_output'  con_name
                tablespace  tablespace_logic
                size_mb     size_mb_logic
                free_mb     free_mb_logic
                block_size  block_size_logic
                status      status_logic
                contents    contents_logic
                extent_man  extent_man_logic
                compression comp_logic.

          lt_tab_list[] = ts_output1[].

          IF lt_tab_list[] IS NOT INITIAL.

            " Title
            CLEAR: ls_output.
            ls_output = 'DB check'.
            APPEND ls_output TO ft_output.

            " Heading Columns
            CLEAR: ls_output.
            CONCATENATE 'Tablespace' lc_sep
            'DB encrypted' INTO ls_output.
            APPEND ls_output TO ft_output.

            " Data
            CLEAR: ls_output.
            LOOP AT lt_tab_list INTO ls_tab_list.
              CONCATENATE ls_tab_list-tablespace lc_sep
              ls_tab_list-encrypted INTO ls_output.
              APPEND ls_output TO ft_output.
            ENDLOOP.

          ELSE.

            " Title
            CLEAR: ls_output.
            ls_output = 'DB check'.
            APPEND ls_output TO ft_output.

            CLEAR: ls_output.
            ls_output = 'No entries found'.
            APPEND ls_output TO ft_output.

          ENDIF.

        WHEN 'MSS'. "MSSQL

          "...local system
          CREATE OBJECT rem_con_ref.

*     Build the SQL statement and execute it.

          "...execute the query
          CREATE OBJECT stmt_ref.

          TRY.
              stmt_ref = rem_con_ref->create_statement( ).

              lv_sql_stmt = 'SELECT' &
              ' db.name,' &
              ' db.is_encrypted,' &
              ' dm.encryption_state,' &
              ' dm.percent_complete,' &
              ' dm.key_algorithm,' &
              ' dm.key_length' &
              ' FROM' &
              ' sys.databases db' &
              ' LEFT OUTER JOIN sys.dm_database_encryption_keys dm' &
              ' ON db.database_id = dm.database_id;'.

              rs_ref = stmt_ref->execute_query( lv_sql_stmt ).
              it_metadata = rs_ref->get_metadata( ).

            CATCH cx_sql_exception INTO lo_sql.
              lv_msg = lo_sql->get_text( ).

              " Title
              CLEAR: ls_output.
              ls_output = 'DB check'.
              APPEND ls_output TO ft_output.

              CLEAR: ls_output.
              ls_output = lv_msg.
              APPEND ls_output TO ft_output.
              RETURN.

          ENDTRY.

          IF it_metadata IS INITIAL.
            " Title
            CLEAR: ls_output.
            ls_output = 'DB check'.
            APPEND ls_output TO ft_output.

            CLEAR: ls_output.
            ls_output = 'No data found'.
            APPEND ls_output TO ft_output.
            RETURN.
          ENDIF.

*     get struct_ref, disable abap_strict mode
          r_metadata =
          rs_ref->get_struct_ref( md_tab  = it_metadata
          p_strict = abap_false ).

*     RTTI - create a tabletype object based on a
*     structdescription based off the metadata
          ex_structdescr ?=
          cl_abap_typedescr=>describe_by_data_ref( r_metadata ).
          r_tabletype     =
          cl_abap_tabledescr=>create( p_line_type  = ex_structdescr
          p_table_kind = cl_abap_tabledescr=>tablekind_std ).

          CREATE DATA ex_result_ref TYPE HANDLE r_tabletype.
          lr_structdescr ?=
          cl_abap_typedescr=>describe_by_data_ref( r_metadata ).
          CREATE DATA lr_structure TYPE HANDLE lr_structdescr.
          ASSIGN lr_structure->* TO <fs_structure>.

          TRY.

              rs_ref->set_param_table( itab_ref = ex_result_ref ).
              rs_ref->next_package( ).
            CATCH cx_sql_exception INTO lo_sql.
              lv_msg = lo_sql->get_text( ).

          ENDTRY.

*    Now we have the data.
          ASSIGN ex_result_ref->* TO <ft_table>.

          " Title
          CLEAR: ls_output.
          ls_output = 'DB check'.
          APPEND ls_output TO ft_output.

          " Heading Columns
          CLEAR: ls_output.
          CONCATENATE 'Name' lc_sep
          'DB encrypted' INTO ls_output.
          APPEND ls_output TO ft_output.

          LOOP AT <ft_table> ASSIGNING <fs_encrypt>.

            ASSIGN COMPONENT 'NAME' OF STRUCTURE <fs_encrypt>
            TO <fs_name>.

            ASSIGN COMPONENT 'IS_ENCRYPTED' OF STRUCTURE <fs_encrypt>
            TO <fs_encrypt_val>.

            lv_encrypted = <fs_encrypt_val>.

            IF lv_encrypted EQ '0'.
              CLEAR: ls_output.
              CONCATENATE <fs_name> lc_sep
              'NO' INTO ls_output.
              APPEND ls_output TO ft_output.
            ELSE.
              CLEAR: ls_output.
              CONCATENATE <fs_name> lc_sep
              'YES' INTO ls_output.
              APPEND ls_output TO ft_output.
            ENDIF.

          ENDLOOP.


        WHEN OTHERS.
*  Begin of changes in V001
          " Incorrect input
          ls_output = lc_ndb.
          APPEND ls_output TO ft_output.
          CLEAR ls_output.
*  End of changes in V001

      ENDCASE.

    WHEN OTHERS.
*  Begin of changes in V001
      " Incorrect input
      ls_output = lc_inc_input.
      APPEND ls_output TO ft_output.
      CLEAR ls_output.
*  End of changes in V001

  ENDCASE.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  GET_TS_LIST
*&---------------------------------------------------------------------*
*      -->P_0163   text
*      -->P_CON_NAME  text
*      -->P_TABLESPACE  text
*      -->P_TABLESPACE_LOGIC  text
*      -->P_SIZE_MB  text
*      -->P_SIZE_MB_LOGIC  text
*      -->P_FREE_MB  text
*      -->P_FREE_MB_LOGIC  text
*      -->P_BLOCK_SIZE  text
*      -->P_BLOCK_SIZE_LOGIC  text
*      -->P_STATUS  text
*      -->P_STATUS_LOGIC  text
*      -->P_CONTENTS  text
*      -->P_CONTENTS_LOGIC  text
*      -->P_EXTENT_MAN  text
*      -->P_EXTENT_MAN_LOGIC  text
*      -->P_COMPRESSION  text
*      -->P_COMP_LOGIC  text
*----------------------------------------------------------------------*
FORM get_ts_list      TABLES ts_output1
USING tab_name TYPE string
      con_name
      tablespace_name     tablespace_name_logic
      size_mb             size_mb_logic
      free_mb             free_mb_logic
      block_size          block_size_logic
      status              status_logic
      contents            contents_logic
      extent_management   extmanagement_logic
      compression         comp_logic.

  DATA: query        TYPE string,
        ts_condition TYPE string,
        l_db_rel     TYPE string.

  l_db_rel = '12'.

* dba_tablespaces where clause content
  ts_condition = ` 1=1`.
  PERFORM add_condition_string USING ts_condition
        'tablespace_name'
        tablespace_name
        tablespace_name_logic.
  PERFORM add_condition_string USING ts_condition 'block_size'
        block_size block_size_logic.
  PERFORM add_condition_string USING ts_condition 'status'
        status status_logic.
  PERFORM add_condition_string USING ts_condition 'contents'
        contents contents_logic.
  PERFORM add_condition_string USING ts_condition
        'extent_management'
        extent_management
        extmanagement_logic.

  IF ( l_db_rel >= 10 ).
    PERFORM add_condition_string USING ts_condition
          'def_tab_compression'
          compression comp_logic.
  ENDIF.

  IF ( l_db_rel >= 11 ).

    query = `select` &
    ` a.ts,` &
    ` a.blk_kb,` &
    ` decode(lower(a.contents),'temporary', d.size_mb, b.size_mb),` &
    ` decode(lower(a.contents),'temporary',` &
    ` d.size_mb-e.used_mb, c.free_mb),` &
    ` a.init_mb,` &
    ` a.next_mb,` &
    ` a.min,` &&
    ` a.max,` &
    ` a.pct,` &
    ` a.extlen,` &
    ` a.status,` &
    ` a.contents,` &
    ` a.logging,` &
    ` a.force_log,` &
    ` a.ext_man,` &&
    ` a.alloc,` &
    ` a.plugged,` &
    ` a.ssm,` &
    ` a.dtc,` &
    ` a.comp_for,` &
    ` a.encrypted,` &
    ` f.alg ` &&
    ` from` &&
    ` (select` &
    ` tablespace_name ts,` &
    ` nvl(block_size,0)/1024 blk_kb,` &&
    ` round(nvl(initial_extent,0)/1024/1024,3) init_mb,` &
    ` round(nvl(next_extent,0)/1024/1024,3) next_mb,` &&
    ` min_extents min,` &
    ` max_extents max,` &
    ` pct_increase pct,` &
    ` round(nvl(min_extlen,0)/1024/1024,3) extlen,` &&
    ` status status,` &
    ` contents contents,` &
    ` logging logging,` &
    ` force_logging force_log,` &
    ` extent_management ext_man,` &&
    ` allocation_type alloc,` &
    ` plugged_in plugged,` &
    ` segment_space_management ssm,` &
    ` def_tab_compression dtc,` &
    ` compress_for comp_for,` &
    ` encrypted encrypted ` &&
    ` from dba_tablespaces` &
    ` where` && ts_condition &&
    ` ) a,` &
    ` (select` &
    ` tablespace_name ts,` &
    ` round(sum(nvl(bytes,0))/1024/1024,2) size_mb` &&
    ` from dba_data_files` &
    ` group by tablespace_name` &
    ` ) b,` &
    ` (select` &
    ` tablespace_name ts,` &&
    ` round(sum(nvl(bytes,0))/1024/1024,2) free_mb` &
    ` from dba_free_space` &&
    ` group by tablespace_name` &
    ` ) c,` &
    ` (select tablespace_name ts,` &
    ` round(sum(nvl(bytes,0))/1024/1024,2) size_mb` &
    ` from dba_temp_files` &
    ` group by tablespace_name ) d,` &&
    ` (select tablespace_name ts,` &&
    ` sum(nvl(bytes_used,0))/1024/1024 used_mb` &
    ` from gv$temp_extent_pool` &
    ` group by tablespace_name) e,` &
    ` (select vts.name tsname, ets.encryptionalg alg from ` &
    `  v$tablespace vts, v$encrypted_tablespaces ets ` &
    `  where vts.ts# = ets.ts#(+) ) f ` &
    ` where` &&
    ` a.ts=b.ts(+) and` & " join condition
    ` a.ts=c.ts(+) and` & " join condition
    ` a.ts=d.ts(+) and` & " join condition
    ` a.ts=e.ts(+) and` & " join condition
    ` a.ts=f.tsname(+) `.

  ENDIF.

  PERFORM add_condition_num USING query 'b.size_mb'
        size_mb size_mb_logic ''.
  PERFORM add_condition_num USING query 'c.free_mb'
        free_mb free_mb_logic ''.

  PERFORM execute_query TABLES ts_output1
  USING query con_name tab_name.


ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  add_condition_string
*&---------------------------------------------------------------------*
*      -->QUERY            text
*      -->FIELD            text
*      -->VALUE            text
*      -->SELECTION_LOGIC  text
*----------------------------------------------------------------------*
FORM add_condition_string USING query TYPE string
      field TYPE string
      value selection_logic.

  DATA: logic TYPE string.

  CHECK NOT value IS INITIAL.

  logic = selection_logic.
* value contains * or % -> selection will be ' like '
  PERFORM search_for_* USING value logic.

  query = query && ` and ` &&
  field && space && logic && ` '` && value && `'`.


ENDFORM.                    "add_condition_string
*&---------------------------------------------------------------------*
*&      Form  add_condition_num
*&---------------------------------------------------------------------*
*      -->QUERY            text
*      -->FIELD            text
*      -->VALUE            text
*      -->SELECTION_LOGIC  text
*      -->EXTENSION        text
*----------------------------------------------------------------------*
FORM add_condition_num USING query TYPE string
      field TYPE string
      value selection_logic
      extension TYPE string.

  CONDENSE value.
  CHECK NOT value IS INITIAL.
  CHECK value CO '1234567890,. '.

* We need translate commas to dots
  PERFORM search_for_commas USING value.
* More than one dot is forbidden!
  PERFORM search_for_dots   USING value.

* field might be empty now
  CHECK NOT value IS INITIAL.

* add leading 0 if start's with '.'
  PERFORM add_zero          USING value.

  IF ( selection_logic = '' ).
    selection_logic = '='.
  ENDIF.

  query = query && ` and ` &&
  field && space && selection_logic && space &&
  value && extension.


ENDFORM.                    "add_condition_num
*&---------------------------------------------------------------------*
*&      Form  execute_query
*&---------------------------------------------------------------------*
*      -->QUERY            text
*      -->I_REMOTE_SYSTEM  text
*      -->ITNAME           text
*----------------------------------------------------------------------*
FORM execute_query TABLES ts_output1
USING query i_remote_system itname.

  TYPES: BEGIN OF tywa_se_add,
           compressed TYPE db02_se_list-compressed,
           logging    TYPE db02_se_list-logging,
         END OF tywa_se_add,

         tywa_db_ge_md  TYPE db02n_dbgemd,

         tytab_db_ge_md TYPE STANDARD TABLE OF tywa_db_ge_md.

  TYPES: BEGIN OF tywa_se_list.
      INCLUDE STRUCTURE db02_se_list.
  TYPES: END OF tywa_se_list.

  TYPES: tytab_se_list TYPE TABLE OF tywa_se_list.

  FIELD-SYMBOLS: <fs_ref> TYPE STANDARD TABLE.


  DATA: tab_db_ge_md TYPE tytab_db_ge_md,
        tab_help     TYPE tytab_se_list,
        tab_se_add   TYPE TABLE OF tywa_se_add,
        se_output    TYPE TABLE OF db02_se_list,
        ts_output    TYPE TABLE OF db02_ts_list,
        us_output    TYPE TABLE OF db02_us_list.

  DATA: stmt_ref TYPE REF TO cl_sql_statement,
        rs_ref   TYPE REF TO cl_sql_result_set.

  DATA: rem_con_ref  TYPE REF TO cl_sql_connection,
        l_sqlerr_ref TYPE REF TO cx_sql_exception,
        adbc_excp    TYPE REF TO cx_dba_adbc.

  DATA: rows_ret TYPE i,
        it_ref   TYPE REF TO data.

*...remote connection
  IF ( ( i_remote_system <> 'DEFAULT' ) AND
  ( i_remote_system <> ' ' ) ).

    TRY.
*...open a remote connection, if not local system
        rem_con_ref =
        cl_sql_connection=>get_connection( i_remote_system ).

      CATCH cx_sql_exception INTO l_sqlerr_ref.
        adbc_excp = cl_dba_cx_factory=>create_dba_adbc(
        sysid     = sy-sysid
        previous  = l_sqlerr_ref
        statement = query
        dbcname   = i_remote_system
        method    = '<NONE>'
        sy_subrc  = sy-subrc ).
        cx_dba_root=>handle_exception_class( adbc_excp ).

    ENDTRY.

  ELSE.
*...local system
    CREATE OBJECT rem_con_ref.
  ENDIF.

*...execute the query
  CREATE OBJECT stmt_ref.
  TRY.
      stmt_ref = rem_con_ref->create_statement( ).
      rs_ref = stmt_ref->execute_query( query ).
    CATCH cx_sql_exception INTO l_sqlerr_ref.
      adbc_excp = cl_dba_cx_factory=>create_dba_adbc(
      sysid     = sy-sysid
      previous  = l_sqlerr_ref
      statement = query
      dbcname   = i_remote_system
      method    = '<NONE>'
      sy_subrc  = sy-subrc ).
      cx_dba_root=>handle_exception_class( adbc_excp ).
  ENDTRY.

  CASE itname.
    WHEN 'tab_db_ge_md'.
      GET REFERENCE OF tab_db_ge_md INTO  it_ref.
    WHEN 'tab_help'.
      GET REFERENCE OF tab_help     INTO  it_ref.
    WHEN 'tab_se_add'.
      GET REFERENCE OF tab_se_add   INTO  it_ref.
    WHEN 'se_output'.
      FREE se_output.
      GET REFERENCE OF se_output    INTO  it_ref.
    WHEN 'ts_output'.
      FREE ts_output.
      GET REFERENCE OF ts_output    INTO  it_ref.
    WHEN 'us_output'.
      FREE us_output.
      GET REFERENCE OF us_output    INTO  it_ref.
  ENDCASE.

  rs_ref->set_param_table( it_ref ).

*...fetch the complete result set into the internal table
  TRY.
      rows_ret = rs_ref->next_package( ).
    CATCH cx_sql_exception INTO l_sqlerr_ref.
      adbc_excp = cl_dba_cx_factory=>create_dba_adbc(
      sysid     = sy-sysid
      previous  = l_sqlerr_ref
      statement = query
      dbcname   = i_remote_system
      method    = '<NONE>'
      sy_subrc  = sy-subrc ).
      cx_dba_root=>handle_exception_class( adbc_excp ).
  ENDTRY.

*...close database connection
  rs_ref->close( ).
  TRY.
      rem_con_ref->close( ).
    CATCH cx_sql_exception INTO l_sqlerr_ref.
      adbc_excp = cl_dba_cx_factory=>create_dba_adbc(
      sysid     = sy-sysid
      previous  = l_sqlerr_ref
      statement = query
      dbcname   = i_remote_system
      method    = '<NONE>'
      sy_subrc  = sy-subrc ).
      cx_dba_root=>handle_exception_class( adbc_excp ).
  ENDTRY.

  ASSIGN it_ref->* TO <fs_ref>.
  ts_output1[] = <fs_ref>.


ENDFORM.                    "execute_query
*&--------------------------------------------------------------------*
*&      Form  search_for_*
*&--------------------------------------------------------------------*
*      -->FIELD       text
*      -->FIELD_LOGIC text
*---------------------------------------------------------------------*
FORM search_for_* USING field field_logic.

  DATA: pattern(2) TYPE c VALUE '*%'.

  IF field_logic IS INITIAL.
    field_logic = '='.
  ELSEIF field_logic = '*'.
    field_logic = ' like'.
  ENDIF.

* We expect * to for generic names...
  FIND '*' IN field.
  IF sy-subrc = 0.
    TRANSLATE field USING pattern.
    IF field_logic = '=' OR field_logic IS INITIAL.
      field_logic = ' like'.
    ELSEIF field_logic = '<>'.
      field_logic = ' not like'.
    ELSE.
      REPLACE ALL OCCURRENCES OF '%' IN field  WITH ''.
      CONDENSE field.
    ENDIF.
  ELSE.
* ... but somebody might use directly %...
    FIND '%' IN field.
    IF sy-subrc = 0.
      IF field_logic = '=' OR field_logic IS INITIAL.
        field_logic = ' like'.
      ELSEIF field_logic = '<>'.
        field_logic = ' not like'.
      ELSE.
        REPLACE ALL OCCURRENCES OF '%' IN field  WITH ''.
        CONDENSE field.
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.                    "search_for_*
*&--------------------------------------------------------------------*
*&      Form  search_for_commas
*&--------------------------------------------------------------------*
*      -->FIELD      text
*---------------------------------------------------------------------*
FORM search_for_commas USING field.

  DATA: pattern(2) TYPE c VALUE ',.'.

* We expect dots to expecify decimals. Anyway for those using commas:
  FIND ',' IN field.
  IF sy-subrc = 0.
    TRANSLATE field USING pattern.
  ENDIF.

ENDFORM.                    "search_for_commas
*&--------------------------------------------------------------------*
*&      Form  search_for_dots
*&--------------------------------------------------------------------*
*      -->FIELD      text
*---------------------------------------------------------------------*
FORM search_for_dots USING field.

  DATA: dumm1 TYPE db02_sel,
        dumm2 TYPE db02_sel,
        dumm3 TYPE db02_sel.

  SPLIT field AT '.' INTO dumm1 dumm2 dumm3.
  IF NOT dumm2 = ''.
    CONCATENATE dumm1 '.' dumm2 INTO field.
  ELSE.
    field = dumm1.
  ENDIF.

ENDFORM.                    "search_for_dots
*&--------------------------------------------------------------------*
*&      Form  add_zero
*&--------------------------------------------------------------------*
*      -->FIELD      text
*---------------------------------------------------------------------*
FORM add_zero USING field.

  IF field(1) = '.'.
    CONCATENATE '0' field INTO field.
  ENDIF.

ENDFORM.                    "add_zero