*---------------------------------------------------------------------*
* Program Name        :   ZCM_SQLSERVER_TOP_TABLES_EXP                *
* Title               :   Top 100 Tables for SQL Server Database      *
* Purpose             :   This report is used to fetch top 100 tables *
*                     :   in the system                               *
*---------------------------------------------------------------------*
* Related Transaction OR Standard Program References                  *
* DBACOCKPIT                                                          *
*---------------------------------------------------------------------*
* Program Change History                                              *
*---------------------------------------------------------------------*
* Date        Version   Author       TR#/Local     Description        *
*---------------------------------------------------------------------*
* 07-02-2020 Initial Ruchir Kamble FIOK900653 To fetch top 100 tables *
* 04-20-2022 V001    Soumya Ray    Local      To add schema in input  *
* 09-26-2022 V002    Soumya Ray    Local      To pass message in case *
*                                             input is wrong or empty *
*---------------------------------------------------------------------*

REPORT zcm_sqlserver_top_tables_exp.

CONSTANTS: lc_sep            TYPE c VALUE '|'               LENGTH 1,
           lc_l              TYPE c VALUE 'L'               LENGTH 1,
           lc_x              TYPE c VALUE 'X'               LENGTH 1,
           lc_maptype        TYPE c VALUE '3'               LENGTH 1,
           lc_top            TYPE c VALUE 'Top'             LENGTH 3,
           lc_fetch          TYPE c VALUE 'FETCH'           LENGTH 5,
           lc_table_name     TYPE c VALUE 'Table name'      LENGTH 10,
           lc_size           TYPE c VALUE 'Size in KB'      LENGTH 15,
           lc_no_rows        TYPE c VALUE 'Number of rows'  LENGTH 16,
           lc_title          TYPE c VALUE 'Large Tables'    LENGTH 13,
           lc_err_msg        TYPE c VALUE
           'No Records found'                               LENGTH 20,
           lc_obj_top_tables TYPE smssrattr-objname
           VALUE 'sap_get_top_tables',
*   Begin of changes in V001
           lc_comma          TYPE c VALUE ','               LENGTH 1,
           lc_schema         TYPE c VALUE 'SchemaName'      LENGTH 11,
           lc_noinput        TYPE c VALUE 'No input passed' LENGTH 30,
           lc_inc_input      TYPE c VALUE 'Incorrect Input' LENGTH 20.
*   End of changes in V001

DATA: ls_input      TYPE tab512,
      ls_output     TYPE tab512,
      lv_action     TYPE char10,
      lv_num_tab    TYPE char10,
      lv_dbname     TYPE mssdb,
      lv_schema     TYPE mssschema,
      lv_used       TYPE char10,
      lv_reserved   TYPE char15,
      lv_data       TYPE char15,
      lv_rows       TYPE char15,
      lv_rowmodctr  TYPE char15,
      ls_conn       TYPE mssconndata,
      lt_inparams   TYPE TABLE OF mssseria,
      lt_largetabs  TYPE TABLE OF msstoplargest,
      ls_largetabs  TYPE msstoplargest,
      lt_resitab    TYPE REF TO data,
      lr_rat_ref    TYPE REF TO cl_mss_rat,
*  Begin of changes in V001
      lv_count      TYPE char11,
      lt_table_tmp  TYPE STANDARD TABLE OF msstoplargest,
      lt_table_tmp1 TYPE STANDARD TABLE OF msstoplargest,
      lt_schema     TYPE STANDARD TABLE OF hdb_schema_name,
      ls_schema     TYPE hdb_schema_name.
*  End of changes in V001

LOAD-OF-PROGRAM.

FORM get_config
               TABLES lt_input  STRUCTURE tab512
                      lt_output STRUCTURE tab512.
* Begin of changes in V002
  ls_output = lc_title.
  APPEND ls_output TO lt_output.
  CLEAR ls_output.
* End of changes in V002

  " Read input file from Python
  READ TABLE lt_input INTO ls_input INDEX 1.
* Begin of changes in V002
  IF sy-subrc NE 0.
    ls_output = lc_noinput. "No input passed
    APPEND ls_output TO lt_output.
    CLEAR ls_output.
    RETURN.
  ENDIF.
* End of changes in V002

  SPLIT ls_input AT lc_sep INTO
  lv_action       " Action
  lv_num_tab      " Number of tables to be fetched
  lv_schema.      " Schema      "+V001

  CASE lv_action.

    WHEN lc_fetch.
      FREE: lt_output. "+V002

*  Begin of changes in V001
*  Fetching all the entries from DB
      SPLIT lv_schema AT lc_comma INTO TABLE lt_schema.
      lv_count = lv_num_tab + 1.
*  End of changes in V001

      " FM to get connection details
      CALL FUNCTION 'SMSS_GET_CONNECTION'
        EXPORTING
          auto_conn = lc_x
        IMPORTING
          currcon   = ls_conn.

      CREATE OBJECT lr_rat_ref
        EXPORTING
          currcon = ls_conn
          objname = lc_obj_top_tables.

      APPEND lv_num_tab       TO lt_inparams.
      APPEND lc_l             TO lt_inparams.
      APPEND ls_conn-dbschema TO lt_inparams.
      APPEND ls_conn-dbname   TO lt_inparams.

      " FM to fetch large tables
      CALL FUNCTION 'SMSS_RAT_GENERIC'
        EXPORTING
          conn              = ls_conn
          maptype           = lc_maptype
          objname           = lc_obj_top_tables
        TABLES
          inparams          = lt_inparams
          t_result          = lt_largetabs
        EXCEPTIONS
          illegal_parameter = 1
          rfc_error         = 2
          data_access_error = 3
          no_authority      = 4
          OTHERS            = 5.

      " Adding title to the output
      CONCATENATE lc_top lv_num_tab lc_title
      INTO ls_output
      SEPARATED BY space.
      APPEND ls_output TO lt_output.

      IF sy-subrc EQ 0.
*   Begin of changes in V001
*   Deleting entries based on input schema
        IF lt_largetabs IS NOT INITIAL.

          SORT lt_largetabs BY schema_name.
          lt_table_tmp[] = lt_largetabs[].

          FREE: lt_largetabs[].

          LOOP AT lt_schema INTO ls_schema.
            lt_table_tmp1[] = lt_table_tmp[].
            DELETE lt_table_tmp1[] WHERE schema_name NE ls_schema.
            APPEND LINES OF lt_table_tmp1[] TO lt_largetabs[].
            CLEAR: ls_schema.
          ENDLOOP.

          SORT lt_largetabs BY used DESCENDING.

          DELETE lt_largetabs FROM lv_count.
        ENDIF.

        IF lt_largetabs IS NOT INITIAL.
*   End of changes in V001
          " Adding headings to the output
          CONCATENATE lc_schema         lc_sep   "+V001
          lc_table_name  lc_sep
          lc_size        lc_sep
          lc_no_rows
          INTO ls_output.
          APPEND ls_output TO lt_output.

          LOOP AT lt_largetabs INTO ls_largetabs.

            lv_used      = ls_largetabs-used.
            lv_rows      = ls_largetabs-rows.

            CONDENSE: lv_used , lv_rows.

            CONCATENATE ls_largetabs-schema_name lc_sep
            ls_largetabs-name     lc_sep
            lv_used               lc_sep
            lv_rows
            INTO ls_output.
            APPEND ls_output TO lt_output.
            CLEAR: ls_output, lv_used, lv_rows.

          ENDLOOP.
*  Begin of changes in V001
        ELSE.
          " No records found
          ls_output = lc_err_msg.
          APPEND ls_output TO lt_output.
          CLEAR ls_output.
        ENDIF.
*  End of changes in V001

      ELSE.
        " No records found
        ls_output = lc_err_msg.
        APPEND ls_output TO lt_output.
        CLEAR ls_output.
      ENDIF.

*  Begin of changes in V002
  WHEN OTHERS.
    ls_output = lc_inc_input. "Incorrect input
    APPEND ls_output TO lt_output.
    CLEAR ls_output.
*  Begin of changes in V002

  ENDCASE.

ENDFORM.