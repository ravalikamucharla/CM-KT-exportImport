*---------------------------------------------------------------------*
* Program Name        :   ZCM_ORACLE_TOP_TABLES_EXP_RCNT              *
* Title               :   Top Tables for Oracle Database              *
* Purpose             :   This report is used to fetch top 100 tables *
*                     :   in the system                               *
*---------------------------------------------------------------------*
* Related Transaction OR Standard Program References                  *
* DBACOCKPIT                                                          *
*---------------------------------------------------------------------*
* Program Change History                                              *
*---------------------------------------------------------------------*
* Date        Version   Author       TR#/Local     Description        *
*---------------------------------------------------------------------*
* 10-25-2022 Initial Yasaswini K   Local    To get top tables based on*
*                                           on record count and       *
*                                           excluding pool and cluster*
*                                           tables                    *
*---------------------------------------------------------------------*

REPORT zcm_oracle_top_tables_exp_rcnt.

LOAD-OF-PROGRAM.

FORM get_config
              TABLES lt_input  STRUCTURE tab512
                     lt_output STRUCTURE tab512.

  CONSTANTS: lc_sep        TYPE c VALUE '|'                LENGTH 1,
             lc_top        TYPE c VALUE 'Top'              LENGTH 3,
             lc_comma      TYPE c VALUE ','                LENGTH 1,
             lc_db_object  TYPE extents_ti-db_object       VALUE '*',
             lc_typ        TYPE extents_ti-s_type          VALUE
                                                                'TABLE',
             lc_tabspace   TYPE extents_ti-table_spc       VALUE '*',
             lc_extent     TYPE dbflags-nr_extents         VALUE '10',
             lc_fetch      TYPE c VALUE 'FETCH'            LENGTH 5,
             lc_table_name TYPE c VALUE 'Table name'       LENGTH 10,
             lc_size       TYPE c VALUE 'Size in KB'       LENGTH 15,
             lc_no_rows    TYPE c VALUE 'Number of rows'   LENGTH 15,
             lc_title      TYPE c VALUE 'Large Tables'     LENGTH 15,
             lc_err_msg    TYPE c VALUE 'No data found'    LENGTH 20,
             lc_noinput    TYPE c VALUE 'No input given'   LENGTH 20,
             lc_title1     TYPE c VALUE 'Fetch Top Tables' LENGTH 20,
             lc_pool       TYPE c VALUE 'POOL'             LENGTH 4,
             lc_cluster    TYPE c VALUE 'CLUSTER'          LENGTH 7,
             lc_inc_input  TYPE c VALUE 'Incorrect input'  LENGTH 20,
             lc_null       TYPE c VALUE 'NULL'             LENGTH 4,
             lc_schema     TYPE c VALUE 'Owner'            LENGTH 5.

  TYPES: BEGIN OF lty_dd02l,
           tabname  TYPE db_object,
           tabclass TYPE tabclass,
         END OF lty_dd02l.

  DATA: ls_input        TYPE tab512,
        ls_output       TYPE tab512,
        lv_action       TYPE char10,
        lv_num_tab      TYPE char10,
        lv_kbytes       TYPE char15,
        lv_no_rows      TYPE char10,
        ls_tablrows     TYPE exp_tablrows,
        lt_tablrows     TYPE STANDARD TABLE OF exp_tablrows,
        lt_largetabs    TYPE TABLE OF extents_ti,
        ls_largetabs    TYPE extents_ti,
        lv_schema       TYPE string,
        lv_dbschema     TYPE char16,
        lt_largetabstmp TYPE TABLE OF extents_ti,
        lt_schema       TYPE STANDARD TABLE OF tbl_owner,
        ls_schema       TYPE tbl_owner,
        lt_dd02l        TYPE STANDARD TABLE OF lty_dd02l,
        ls_dd02l        TYPE lty_dd02l.

* Adding title to the output
  ls_output = lc_title1.
  APPEND ls_output TO lt_output.
  CLEAR: ls_output.

  " Read input file from Python
  READ TABLE lt_input INTO ls_input INDEX 1.
  IF sy-subrc EQ 0.
    SPLIT ls_input AT lc_sep INTO
    lv_action       " Action
    lv_num_tab      " Number of tables to be fetched
    lv_schema.      "Schema (owner) as input

  ELSE.
    " No input given
    ls_output = lc_noinput.
    APPEND ls_output TO lt_output.
    CLEAR ls_output.
    RETURN.
  ENDIF.


  CASE lv_action.

    WHEN lc_fetch.

      IF lv_schema IS INITIAL.

        CALL FUNCTION 'DB_DBSCHEMA_CURRENT'
          IMPORTING
            dbschema = lv_dbschema.

        IF sy-subrc = 0.
          lv_schema = lv_dbschema.
        ENDIF.

      ENDIF.

      SPLIT lv_schema AT lc_comma INTO TABLE lt_schema.

      FREE: lt_largetabs.

      LOOP AT lt_schema INTO ls_schema.

        " FM to fetch tables
        CALL FUNCTION 'DB_ORA_EXTENTS'
          EXPORTING
            owner            = ls_schema
            db_object        = lc_db_object
            type             = lc_typ
            tabspace         = lc_tabspace
            extents          = lc_extent
          TABLES
            table_of_extents = lt_largetabstmp.

        IF sy-subrc = 0.
          APPEND LINES OF lt_largetabstmp TO lt_largetabs.

          FREE: lt_largetabstmp[].
          CLEAR: ls_schema.
        ENDIF.
      ENDLOOP.

      "To delete title
      FREE: lt_output[].

      " Adding title to the output
      CONCATENATE lc_top lv_num_tab lc_title
                  INTO ls_output
                  SEPARATED BY space.
      APPEND ls_output TO lt_output.
      CLEAR ls_output.

      IF lt_largetabs IS NOT INITIAL.

        SELECT tabname tabclass INTO TABLE lt_dd02l
          FROM dd02l
          WHERE ( tabclass EQ lc_pool AND tabclass EQ lc_cluster ).

        IF sy-subrc = 0.
          SORT lt_dd02l BY tabname.
        ENDIF.

        " Sorting the tables to get large tables
        SORT lt_largetabs DESCENDING BY k_bytes .

        " Adding headings to the output
        CONCATENATE lc_schema         lc_sep
                    lc_table_name     lc_sep
                    lc_size           lc_sep
                    lc_no_rows
                    INTO ls_output.
        APPEND ls_output TO lt_output.
        CLEAR ls_output.


        LOOP AT lt_largetabs INTO ls_largetabs.

          READ TABLE lt_dd02l INTO ls_dd02l WITH KEY
          tabname = ls_largetabs-db_object.

          IF sy-subrc NE 0.

            FREE lt_tablrows.
            ls_tablrows-tabname = ls_largetabs-db_object.
            APPEND ls_tablrows TO lt_tablrows.

            " FM to get the number of rows in the table
            CALL FUNCTION 'EM_GET_NUMBER_OF_ENTRIES'
              TABLES
                it_tables = lt_tablrows.

            READ TABLE lt_tablrows INTO ls_tablrows INDEX 1.

            IF sy-subrc = 0.

              IF ls_tablrows-tabrows > 0.
                lv_no_rows    = ls_tablrows-tabrows.
              ELSE.
                lv_no_rows    = 0.
              ENDIF.

            ENDIF.

            lv_kbytes     = ls_largetabs-k_bytes.

            CONDENSE: lv_kbytes, lv_no_rows.

            IF ls_largetabs-owner IS INITIAL.
              ls_largetabs-owner = lc_null.
            ENDIF.

            IF lv_no_rows IS INITIAL.
              lv_no_rows = lc_null.
            ENDIF.

            CONCATENATE ls_largetabs-owner      lc_sep
                        ls_largetabs-db_object  lc_sep
                        lv_kbytes               lc_sep
                        lv_no_rows
                        INTO ls_output.
            APPEND ls_output TO lt_output.
            CLEAR: ls_output, lv_kbytes.

          ENDIF.

          CLEAR: ls_dd02l, ls_largetabs.

        ENDLOOP.

        lv_num_tab = lv_num_tab + 2.

        DELETE lt_output FROM lv_num_tab.

        "Adding NULL values in between
        DO.
          REPLACE ALL OCCURRENCES OF SUBSTRING '||'
          IN TABLE lt_output WITH '|NULL|'.
          FIND '||' IN TABLE lt_output.
          IF sy-subrc <> 0.
            EXIT .
          ENDIF.
        ENDDO.

      ELSE.
        " No records found
        ls_output = lc_err_msg.
        APPEND ls_output TO lt_output.
        CLEAR ls_output.

      ENDIF.

    WHEN OTHERS.
      " Incorrect input
      ls_output = lc_inc_input.
      APPEND ls_output TO lt_output.
      CLEAR ls_output.

  ENDCASE.
ENDFORM.